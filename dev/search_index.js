var documenterSearchIndex = {"docs":
[{"location":"man/database/","page":"Database studies","title":"Database studies","text":"TBD","category":"page"},{"location":"man/database/","page":"Database studies","title":"Database studies","text":"In the meantime, check determine_topology_dataset, guess_topology_dataset, and TopologyResult.","category":"page"},{"location":"lib/internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.Crystal\nCrystalNets.Clusters\nCrystalNets.CollisionNode\nCrystalNets.Cell\nCrystalNets.CIF\nCrystalNets.EquivalentPosition","category":"page"},{"location":"lib/internals/#CrystalNets.Crystal","page":"Internals","title":"CrystalNets.Crystal","text":"Crystal\n\nIntermediate representation of a crystal, retaining information on the cell, and the fractional placement of the atoms and their type, as well as the residues which will be used as vertices for the computation of the underlying topology.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#CrystalNets.Clusters","page":"Internals","title":"CrystalNets.Clusters","text":"Clusters\n\nClassification of the atoms of a crystalline framework in different clusters. For simple crystals, every atom is its own cluster. For a MOF, a cluster is a SBU, which can be either organic or inorganic.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#CrystalNets.CollisionNode","page":"Internals","title":"CrystalNets.CollisionNode","text":"CollisionNode\n\nStore the structure of a collision node through the subgraph g extracted with only the edges bond to the vertices in the node.\n\nThe num field corresponds to the number of vertices in g that collide in the initial graph, while the neighs field stores the indices of their neighbor out of the collision site.\n\nThe colliding vertices are the num first vertices of g, the others are the neighbors. In particular, nv(g) == num + length(neighs) and g[(num+1):(nv(g))] has no edge.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#CrystalNets.Cell","page":"Internals","title":"CrystalNets.Cell","text":"Cell\n\nRepresentation of a periodic cell in 3D. Contains information about the cell (axes lengths and angles) and its symmetry group, through its Hall number.\n\nSee SPACE_GROUP_HALL, SPACE_GROUP_FULL, SPACE_GROUP_HM and SPACE_GROUP_IT for the correspondance between Hall number and usual symbolic representations.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#CrystalNets.CIF","page":"Internals","title":"CrystalNets.CIF","text":"CIF\n\nRepresentation of a .cif file.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#CrystalNets.EquivalentPosition","page":"Internals","title":"CrystalNets.EquivalentPosition","text":"EquivalentPosition\n\nRepresentation of a symmetry operation in 3D, defined by an affine function.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Core-topology-functions","page":"Internals","title":"Core topology functions","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.topological_key\nCrystalNets.CRYSTAL_NETS_ARCHIVE\nCrystalNets.minimize\nCrystalNets.candidate_key\nCrystalNets.possible_translations\nCrystalNets.find_all_valid_translations\nCrystalNets.minimal_volume_matrix\nCrystalNets.reduce_with_matrix\nCrystalNets.partition_by_coordination_sequence\nCrystalNets.find_candidates\nCrystalNets.extract_through_symmetry\nCrystalNets.find_initial_candidates\nCrystalNets.find_candidates_onlyneighbors\nCrystalNets.find_candidates_fallback","category":"page"},{"location":"lib/internals/#CrystalNets.topological_key","page":"Internals","title":"CrystalNets.topological_key","text":"topological_key(net::CrystalNet)\n\nReturn a unique topological key for the net, which is a topological invariant of the net (i.e. it does not depend on its initial representation).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.CRYSTAL_NETS_ARCHIVE","page":"Internals","title":"CrystalNets.CRYSTAL_NETS_ARCHIVE","text":"const CRYSTAL_NETS_ARCHIVE::Dict{String,String}\n\nThe archive used to recognize known topologies.\n\nYou probably don't need to access it directly: rely on recognize_topology to read and the various archive functions like add_to_current_archive! to write.\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#CrystalNets.minimize","page":"Internals","title":"CrystalNets.minimize","text":"minimize(net::CrystalNet, collisions::Vector{CollisionNode})\n\nReturn a CrystalNet representing the same net as the input, but in a unit cell.\n\nThe computed unit cell may depend on the representation of the input, i.e. it is not topologicallly invariant.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.candidate_key","page":"Internals","title":"CrystalNets.candidate_key","text":"candidate_key(net::CrystalNet, u, basis, minimal_edgs)\n\nGiven the net, a candidate u => basis where u is the origin and basis the triplet of axes, and minimal_edgs the last minimal key (for the pseudo-lexicographical order used), extract the key corresponding to the current candidate.\n\nThe key is the lexicographically ordered list of edges of the graph when its vertices are numbered according to the candidate. The ordering of keys first compares the list of edges disregarding the offsets, and then only compares the offsets if the rest is identical.\n\nIf the key is larger or equal to minimal_edgs, early stop and return two empty lists. Otherwise, the extracted key is the current best: return the vmap between the initial vertices and their ordered image in the candidate, as well as the key.\n\nSee also: find_candidates\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.possible_translations","page":"Internals","title":"CrystalNets.possible_translations","text":"possible_translations(c::CrystalNet)\n\nReturn a list of tuples (nz, i_max_den, max_den, t) where\n\nt is a translation mapping at the origin vertex to another one in the unit cell.\nmax_den is the maximum denominator in the D coefficients of t.\ni_max_den is the index.\nnz is the number of zeros in t.\n\nThe list is guaranteed to contain all the possible valid translations but may contain some invalid translations.\n\nSee also: check_valid_symmetry, find_all_valid_translations\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.find_all_valid_translations","page":"Internals","title":"CrystalNets.find_all_valid_translations","text":"find_all_valid_translations(c::CrystalNet{D}, collisions) where D\n\nReturn a D-tuple of list of tuples (i_max_den, max_den, t) (see possible_translations for interpretation) where the n-th list contains all valid translations of the net having exactly n-1 zeros.\n\nA translation is valid if it maps exactly each vertex to a vertex and each edge to an edge.\n\nSee also: check_valid_symmetry, possible_translations\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.minimal_volume_matrix","page":"Internals","title":"CrystalNets.minimal_volume_matrix","text":"minimal_volume_matrix(translations::NTuple{D}) where {D}\n\nGiven the output of find_all_valid_translations, compute the transformation that allows reducing the net to its minimal cell.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.reduce_with_matrix","page":"Internals","title":"CrystalNets.reduce_with_matrix","text":"reduce_with_matrix(c::CrystalNet, mat, shrunk_net, collisions)\n\nGiven the net and the output of minimal_volume_matrix computed on the valid translations of the net, return the new net representing the initial net in the computed unit cell.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.partition_by_coordination_sequence","page":"Internals","title":"CrystalNets.partition_by_coordination_sequence","text":"partition_by_coordination_sequence(graph, vmaps=nothing)\n\nPartition the vertices of the graph into disjoint categories, one for each coordination sequence. The partition is then sorted by order of coordination sequence. This partition does not depend on the representation of the graph. The optional argument vmaps is a set of permutations of the vertices that leave the graph unchanged. In other words, vmaps is a set of symmetry operations of the graph.\n\nReturn the categories and a list of unique representative for each symmetry class.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.find_candidates","page":"Internals","title":"CrystalNets.find_candidates","text":"find_candidates(net::CrystalNet{D}, collisions::Vector{CollisionNode}) where D\n\nReturn a non-empty set of candidates u => basis where u is a vertex and basis is matrix whose columns are D linearly independent euclidean embeddings of edges. The returned set is independent of the representation of the graph used in net.\n\nAlso return a category_map linking each vertex to its category number, as defined by partition_by_coordination_sequence\n\nSee also: candidate_key\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.extract_through_symmetry","page":"Internals","title":"CrystalNets.extract_through_symmetry","text":"extract_through_symmetry(candidates::Dict{Int,Vector{SMatrix{3,3,T,9}}}, vmaps, rotations) where T\n\nGiven the candidates and the list of symmetries of the net, return the flattened list of candidates after removing candidates that are symmetric images of the kept ones.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.find_initial_candidates","page":"Internals","title":"CrystalNets.find_initial_candidates","text":"find_initial_candidates(net::CrystalNet{D}, candidates_v, category_map) where D\n\nGiven the net, a list of vertices in a given category and the category_map, return a list of pairs u => (basis, cats) where u ∈ candidates_v, basis is a D-rank matrix made by juxtaposing the euclidean embeddings of outgoing edges from u, and cats are the categories of the respective neighbors of u.\n\nIf the basis corresponding to vertex u is not of rank D, it is not included in the returned list (for instance, if all outgoing edges of a vertex are coplanar with D == 3).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.find_candidates_onlyneighbors","page":"Internals","title":"CrystalNets.find_candidates_onlyneighbors","text":"find_candidates_onlyneighbors(net::CrystalNet{D}, candidates_v, category_map) where D\n\nGiven the net, a list of vertices in a given category and the category_map, return a Dict whose pairs u => matv are such that u ∈ candidates_v and matv is a list of unique invertible matrices of size D whose columns are euclidean embeddings of outgoing edges from u. Each such matrix has a category, defined by the D-uplet of categories of each corresponding outneighbor of u: the returned Dict is such that all the matrices belonging to all matv share the same category.\n\nThe returned Dict is empty iff find_initial_candidates(net, candidates_v, category_map) is empty.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.find_candidates_fallback","page":"Internals","title":"CrystalNets.find_candidates_fallback","text":"find_candidates_fallback(net::CrystalNet3D, reprs, othercats, category_map)\n\nReturn candidates in the same form as find_candidates_onlyneighbors except that only two edges start from u and one does not.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Input","page":"Internals","title":"Input","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.parse_cif\nCrystalNets.CIF(file_path::AbstractString)\nCrystalNets.find_refid\nBase.parse(::Type{CrystalNets.EquivalentPosition}, s::AbstractString, refid=(\"x\", \"y\", \"z\"))\nCrystalNets.check_collision\nCrystalNets.fix_atom_on_a_bond!\nCrystalNets.least_plausible_neighbours\nCrystalNets.fix_valence!\nCrystalNets.sanitize_removeatoms!\nCrystalNets.remove_triangles!\nCrystalNets.remove_homoatomic_bonds!\nCrystalNets.sanity_checks!","category":"page"},{"location":"lib/internals/#CrystalNets.parse_cif","page":"Internals","title":"CrystalNets.parse_cif","text":"parse_cif(file_path)\n\nParse a CIF file and return a dictionary where each identifier (without the starting '_' character) is linked to its value. Values are either a string or a vector of string (if defined in a loop).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.CIF-Tuple{AbstractString}","page":"Internals","title":"CrystalNets.CIF","text":"CIF(file_path::AbstractString)\n\nMake a CIF object out of the parsed file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#CrystalNets.find_refid","page":"Internals","title":"CrystalNets.find_refid","text":"Find the reference identifiers for the three dimensions for the CIF group called symmetry_equiv_pos_as_xyz or space_group_symop_operation_xyz. Usually this is simply (\"x\", \"y\", \"z\").\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Base.parse","page":"Internals","title":"Base.parse","text":"Base.parse(::Type{EquivalentPosition}, s::AbstractString, refid=(\"x\", \"y\", \"z\"))\n\nParse a string into its represented EquivalentPosition given the name of the three variables obtained from find_refid.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.check_collision","page":"Internals","title":"CrystalNets.check_collision","text":"check_collision(pos, mat)\n\nGiven a list of fractional coordinates pos and the matrix of the unit cell mat, return a list of atoms that are suspiciously close to another atom of the list. For each collision site, only one atom is not present in the returned list.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.fix_atom_on_a_bond!","page":"Internals","title":"CrystalNets.fix_atom_on_a_bond!","text":"fix_atom_on_a_bond!(graph, pos, mat)\n\nRemove bonds that are intercepted by an atom. \n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.least_plausible_neighbours","page":"Internals","title":"CrystalNets.least_plausible_neighbours","text":"least_plausible_neighbours(Δs, n)\n\nFind the positions of the n least probable neighbours of an atom, given the list Δs of the distance between their position and that of the atom.\n\nThis function is highly empirical and should not be considered utterly reliable.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.fix_valence!","page":"Internals","title":"CrystalNets.fix_valence!","text":"fix_valence!(graph::PeriodicGraph3D, pos, types, passO, passCN, mat, ::Val{dofix}, options) where {dofix}\n\nAttempt to ensure that the coordinence of certain atoms are at least plausible by removing some edges from the graph. These atoms are H, halogens, O, N and C. if dofix is set, actually modify the graph; otherwise, only emit a warning. In both cases, return a list of atoms with invalid coordinence.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.sanitize_removeatoms!","page":"Internals","title":"CrystalNets.sanitize_removeatoms!","text":"sanitize_removeatoms!(graph::PeriodicGraph3D, pos, types, mat, options)\n\nSpecial heuristics to remove atoms that seem to arise from an improper cleaning of the file. Currently implemented:\n\nC atoms suspiciously close to metallic atoms.\nOne of two identical metallic atoms suspiciously close to one another\n\nTODO:\n\nO atoms with 4 coplanar bonds (warning only).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.remove_triangles!","page":"Internals","title":"CrystalNets.remove_triangles!","text":"remove_triangles!(graph::PeriodicGraph3D, pos, types, mat, toinvestigate=collect(edges(graph)))\n\nIn a configuration where atoms A, B and C are pairwise bonded, remove the longest of the three bonds if it is suspicious (too large and too close to the third atom).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.remove_homoatomic_bonds!","page":"Internals","title":"CrystalNets.remove_homoatomic_bonds!","text":"remove_homoatomic_bonds!(graph::PeriodicGraph, types, targets, ignore_homometallic)\n\nRemove from the graph all bonds of the form X-X where X is an atom in targets. Also remove all such bonds where X is a metal if the two bonded atoms up to third neighbours otherwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.sanity_checks!","page":"Internals","title":"CrystalNets.sanity_checks!","text":"sanity_checks!(graph, pos, types, mat, options)\n\nPerform some sanity checks to ensure that the detected bonds are not obviously wrong because they are either too short or too long.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Crystal-and-CIF-handling","page":"Internals","title":"Crystal and CIF handling","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.cell_parameters\nCrystalNets.periodic_distance\nCrystalNets.remove_partial_occupancy\nCrystalNets.prune_collisions\nCrystalNets.expand_symmetry\nCrystalNets.trim_monovalent\nCrystalNets.trimmed_crystal\nCrystalNets.trim_topology\nCrystalNets.equilibrium","category":"page"},{"location":"lib/internals/#CrystalNets.cell_parameters","page":"Internals","title":"CrystalNets.cell_parameters","text":"cell_parameters(cell::Cell)\n\nThe sextuplet of cell parameters (a, b, c, α, β, γ).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.periodic_distance","page":"Internals","title":"CrystalNets.periodic_distance","text":"periodic_distance(u, mat, ortho=nothing, safemin=nothing)\n\nDistance between point u and the origin, given as a triplet of fractional coordinates, in a repeating unit cell of matrix mat. The distance is the shortest between all equivalents of u and the origin. If ortho is set to true, the angles α, β and γ of the cell are assumed right, which accelerates the computation by up to 7 times. If a distance lower than safemin is computed, stop trying to find a periodic image of u closer to the origin. If unspecified, both ortho and safemin are automatically determined from mat.\n\nThis implementation assumes that the cell corresponds to a reduced lattice. It may be invalid for some edge cases otherwise.\n\nFor optimal performance, use periodic_distance! with buffer, ortho and safemin obtained from prepare_periodic_distance_computations.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.remove_partial_occupancy","page":"Internals","title":"CrystalNets.remove_partial_occupancy","text":"remove_partial_occupancy(::CIF)\n\nOnly keep one atom per atom site.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.prune_collisions","page":"Internals","title":"CrystalNets.prune_collisions","text":"prune_collisions(::CIF)\n\nFor each site where there are atoms suspiciously close to one another, remove all but one of them. This arises for example when all the possible positions of at atom are superposed in the CIF file, typically for a solvent which should be disregarded anyway.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.expand_symmetry","page":"Internals","title":"CrystalNets.expand_symmetry","text":"expand_symmetry(::CIF)\n\nApplies all the symmetry operations listed in the CIF file to the atoms and the bonds.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.trim_monovalent","page":"Internals","title":"CrystalNets.trim_monovalent","text":"trim_monovalent(crystal)\n\nRepeatedly remove monovalent atoms from the crystal until none is left.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.trimmed_crystal","page":"Internals","title":"CrystalNets.trimmed_crystal","text":"trimmed_crystal(c::Crystal{Nothing})\n\nRebuild the crystal after trimming its graph according to trim_topology.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.trim_topology","page":"Internals","title":"CrystalNets.trim_topology","text":"trim_topology(graph::PeriodicGraph)\n\nReturn a pair (vmap, newgraph) extracted from the input by removing vertices of valence lower or equal to 1, and by replacing vertices of valence 2 by edges, until convergence. The only exceptions are vertices only bonded to their representatives of another cell: those will not be replaced by edges even if their valence is 2, since this latter case indicates an irreducible trivial 1-dimensional topology.\n\nvmap maps the vertices of newgraph to their counterpart in graph.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.equilibrium","page":"Internals","title":"CrystalNets.equilibrium","text":"equilibrium(g::PeriodicGraph)\n\nReturn an equilibrium placement for the vertices of the graph, defined as a set of positions such that each vertex is at the barycentre of its neighbors. The returned equilibrium placement is such that the first vertex of the graph is at the origin of the space.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Bond-guessing","page":"Internals","title":"Bond guessing","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.guess_bonds\nCrystalNets.edges_from_bonds","category":"page"},{"location":"lib/internals/#CrystalNets.guess_bonds","page":"Internals","title":"CrystalNets.guess_bonds","text":"guess_bonds(pos, types, mat, options)\n\nReturn the bonds guessed from the positions, types and cell matrix, given as a Vector{Vector{Tuple{Int,Float32}}}.\n\nThe i-th entry of the list is a list, whose entries are of the form (j, dist) which indicates that the representatives of vertices i and j distant of at most dist are bonded together.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.edges_from_bonds","page":"Internals","title":"CrystalNets.edges_from_bonds","text":"edges_from_bonds(bonds::Vector{Vector{Tuple{Int,Float32}}}, mat, pos)\n\nGiven a bond list bonds containing triplets (a, b, dist) where atoms a and b are bonded if their distance is lower than dist, the 3×3 matrix of the cell mat and the Vector{SVector{3,Float64}} pos whose elements are the fractional positions of the atoms, extract the list of PeriodicEdge3D corresponding to the bonds. Since the adjacency matrix wraps bonds across the boundaries of the cell, the edges are extracted so that the closest representatives are chosen to form bonds.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Clustering-algorithm","page":"Internals","title":"Clustering algorithm","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.find_sbus\nCrystalNets.regroup_sbus\nCrystalNets.regroup_paddlewheel!\nCrystalNets.split_sbu!\nCrystalNets.reclassify!\nCrystalNets.add_to_newclass!\nCrystalNets.in_small_cycles_around\nCrystalNets.group_cycle\nCrystalNets.collapse_clusters\nCrystalNets.pem_to_pe\nCrystalNets.allnodes_to_singlenodes","category":"page"},{"location":"lib/internals/#CrystalNets.find_sbus","page":"Internals","title":"CrystalNets.find_sbus","text":"find_sbus(crystal, kinds=default_sbus)\n\nRecognize SBUs using heuristics based on the atom types corresponding to the AllNodes clustering algorithm.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.regroup_sbus","page":"Internals","title":"CrystalNets.regroup_sbus","text":"regroup_sbus(graph::PeriodicGraph3D, classes::AbstractVector{<:Integer},\n             isolate=Int[])\n\nGiven a classification of vertices into classes, separate the vertices into clusters of contiguous vertices belonging to the same class.\n\nisolate is a list where each atom is separated from the rest of its class. Once all such atoms of its class are isolated, we look for the connected components of non-isolated atoms in that class. If such a component has only one neighbours which is an isolated atom, it is added to the vertex of the isolated atom.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.regroup_paddlewheel!","page":"Internals","title":"CrystalNets.regroup_paddlewheel!","text":"regroup_paddlewheel!(graph, clusters::Clusters, types, periodicsbus)\n\nIdentify paddle-wheel patterns made of two opposite SBUs and regroup them into one.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.split_sbu!","page":"Internals","title":"CrystalNets.split_sbu!","text":"split_sbu!(sbus, graph, i_sbu, classes)\n\nSplit SBU number i_sbu into new SBUs according to the updated classes. The first argument sbus is modified in-place. Return the list of newly-created periodic SBUs, if any.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.reclassify!","page":"Internals","title":"CrystalNets.reclassify!","text":"reclassify!(sbus, newperiodicsbus, newclass, graph, types, classof, i_sbu)\n\nReclassify the atoms of sbus.sbus[i_sbu]) according to the following algorithm:\n\nLet's call \"target atom\" any atom of type typ where classof[typ] == deg and either deg == 0 or deg > 0 and the degree of the atom is deg.\nAssign a new SBU for each target atom (one new per atom).\nLook at the connected components of atoms in the SBU which are not target atoms. For each connected component that is finite (aperiodic) and has only one neighbor which is a target atom, put that component in the same SBU as the neighbor.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.add_to_newclass!","page":"Internals","title":"CrystalNets.add_to_newclass!","text":"add_to_newclass!(classes, graph, sbus, new_class, v, types, noneighborof)\n\nSet the class of v to new_class. Then, grow the newly created class by adding connected components of the SBU of v such that the new class does not become periodic and does not contain any vertex that is a neighbor of a vertex whose type is in noneighborof.\n\nIf types === nothing, disregard the condition on noneighborof.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.in_small_cycles_around","page":"Internals","title":"CrystalNets.in_small_cycles_around","text":"in_small_cycles_around(graph, pos, mat, i, classes, acceptedclasses)\n\nReturn the set of atoms belonging to a small cycle to which also belongs atom i. This cycle must only contain atoms whose class is in acceptedclasses\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.group_cycle","page":"Internals","title":"CrystalNets.group_cycle","text":"group_cycle(organiccycle, types, graph)\n\nReturn a list of Vector{PeriodicVertex3D} where each sublist consists in atoms belonging to the same cycle, and which should thus belong to the same vertex eventually.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.collapse_clusters","page":"Internals","title":"CrystalNets.collapse_clusters","text":"collapse_clusters(crystal::Crystal)\n\nReturn the list of crystals corresponding to the input where each cluster has been transformed into a new vertex, for each targeted clustering.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.pem_to_pe","page":"Internals","title":"CrystalNets.pem_to_pe","text":"pem_to_pe(cryst::Crystal{Nothing})\n\nConvert PEM result to PE by removing all metallic sbus.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.allnodes_to_singlenodes","page":"Internals","title":"CrystalNets.allnodes_to_singlenodes","text":"allnodes_to_singlenodes(cryst::Crystal)\n\nConvert AllNodes result to SingleNodes by collapsing all points of extension clusters bonded together into a new organic cluster.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Symmetry-handling","page":"Internals","title":"Symmetry handling","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.SPACE_GROUP_HALL\nCrystalNets.SPACE_GROUP_HM\nCrystalNets.SPACE_GROUP_FULL\nCrystalNets.SPACE_GROUP_IT\nCrystalNets.HALL_SYMBOLS","category":"page"},{"location":"lib/internals/#CrystalNets.SPACE_GROUP_HALL","page":"Internals","title":"CrystalNets.SPACE_GROUP_HALL","text":"Dictionnary mapping the Hall symbol of a symmetry group to its Hall number.\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#CrystalNets.SPACE_GROUP_HM","page":"Internals","title":"CrystalNets.SPACE_GROUP_HM","text":"Dictionnary mapping the HM symbol of a symmetry group to its Hall number.\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#CrystalNets.SPACE_GROUP_FULL","page":"Internals","title":"CrystalNets.SPACE_GROUP_FULL","text":"Dictionnary mapping the full notation representation of a symmetry group to its Hall number, if the full notation is distinct from the H-M symbol.\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#CrystalNets.SPACE_GROUP_IT","page":"Internals","title":"CrystalNets.SPACE_GROUP_IT","text":"Dictionnary mapping the International Table number of a symmetry group to its Hall number\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#CrystalNets.HALL_SYMBOLS","page":"Internals","title":"CrystalNets.HALL_SYMBOLS","text":"List of Hall symbols and crystal system corresponding to each Hall number\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#Unstable-nets","page":"Internals","title":"Unstable nets","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.shrink_collisions\nCrystalNets.order_collision\nCrystalNets.expand_collisions\nCrystalNets.CollisionNode(graph::PeriodicGraph, node::UnitRange{Int}, vmap=nothing)\nCrystalNets.collision_nodes","category":"page"},{"location":"lib/internals/#CrystalNets.shrink_collisions","page":"Internals","title":"CrystalNets.shrink_collisions","text":"shrink_collisions(net::CrystalNet, collisions)\n\nRemove all colliding vertices and replace them by one new vertex per CollisionNode, whose neighbours are that of the vertices within.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.order_collision","page":"Internals","title":"CrystalNets.order_collision","text":"order_collision(graph::PeriodicGraph, colliding)\n\nGiven collision node (in the form of the corresponding list of colliding vertices), find an ordering of them which is independent of the current ordering of these vertices and of vertices which are neither in the collision node nor any of its neighbours. Return an empty list if it fails.\n\nThis function assumes that no vertex in the node has a neighbour in another collision node and that there are no two representatives of the same vertex that are neighbour to some vertices in the range.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.expand_collisions","page":"Internals","title":"CrystalNets.expand_collisions","text":"expand_collisions(collisions::Vector{CollisionNode}, graph::PeriodicGraph, vmap)\n\nExpand each collision node into the appropriate number of vertices so that the resulting graph is isomorphic to the initial one, in a manner that only depends on the current graph. Return the resulting graph.\n\nvmap is the map of vertices between initial_graph (with collapsed collision nodes) and graph\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.CollisionNode-2","page":"Internals","title":"CrystalNets.CollisionNode","text":"CollisionNode(graph::PeriodicGraph, node::UnitRange{Int}, vmap=nothing)\n\nReturn a canonical CollisionNode identifying the collision node. This depends on the order of its neighbours, which is given by their order in the graph or in vmap if provided.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#CrystalNets.collision_nodes","page":"Internals","title":"CrystalNets.collision_nodes","text":"collision_nodes(c::CrystalNet)\n\nCheck that the net is stable, i.e. that no two vertices have the same equilibrium placement.\n\nA net is still considered stable if the collisions in equilibrium placement cannot lead to different topological genomes. In practice, this happens when: A) there is no edge between two collision sites and B) there is no edge between a collision site and two representatives of the same vertex and C) for each collision site either:\n\nthe site is made of at most 4 vertices, or\nno 2 vertices on the site share the same exact set of neighbours out of the site.\n\nIn this case, return the list of corresponding CollisionNode, the list being empty if the net is truly stable. Otherwise, return nothing.\n\nAlso return an updated net where the vertices in a CollisionNode are collapsed into a new vertex, appearing after the non-colliding vertices.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Utils","page":"Internals","title":"Utils","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.@toggleassert\nCrystalNets.check_dimensionality\nCrystalNets.check_valid_symmetry","category":"page"},{"location":"lib/internals/#CrystalNets.@toggleassert","page":"Internals","title":"CrystalNets.@toggleassert","text":"@toggleassert expression\n\nInternal macro used to assert and expression conditionally on a build-time constant. To toggle on or off these assertions, the constant has to be modified in the source code and the module rebuilt afterwards.\n\n\n\n\n\n","category":"macro"},{"location":"lib/internals/#CrystalNets.check_dimensionality","page":"Internals","title":"CrystalNets.check_dimensionality","text":"check_dimensionality(c::CrystalNet)\n\nCheck that the dimensionality of the net (i.e. the number of independent axes along which it is periodic) is equal to D, or throw a DimensionMismatch otherwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.check_valid_symmetry","page":"Internals","title":"CrystalNets.check_valid_symmetry","text":"check_valid_symmetry(c::CrystalNet{D,T}, t::SVector{D,T}, collisions, r=nothing)\n\nCheck that the net is identical to that rotated by r (if it is not nothing) then translated by t. collisions is the list of CollisionNodes in the net.\n\nIf so, return the vmap between the initial vertices and their translated images. Otherwise, return nothing.\n\nSee also: possible_translations, find_all_valid_translations\n\n\n\n\n\n","category":"function"},{"location":"man/visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"When processing individual files through CrystalNets.jl, it is often useful to check whether the detected net actually corresponds to the expected one. To allow this, both the parsed input file as well as the detected subnets are automatically exported by default as VTF files. This file format is recognized by the molecular visualization program VMD and has the property of including explicit bonds, which is necessary in order to represent nets in an unambiguous way.","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"This mini-tutorial shows a setup to conveniently use VMD to check the adequate superposition of the crystal and its underlying net. It is not a VMD tutorial itself: to find more resources, check the official website.","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"tip: Tip\nTo toggle off the automatic export of VTF files, use CrystalNets.toggle_export. The automatic export setting is bypassed when giving explicity values to export_* keyword arguments through CrystalNets.Options or directly to the determine_topology function (and other related functions).","category":"page"},{"location":"man/visualization/#VMD-setup","page":"Visualization","title":"VMD setup","text":"","category":"section"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"After downloading and installing VMD, it can be convenient to customize your setup to taylor your needs. In addition to the official VMD website, an excellent resource for this is Axel Kohlmeyer's personal website.","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"The following code, heavily inspired from that website, can be appended to your .vmdrc or vmd.rc file to automatically show VTF files using CPK representations, with big spheres and bonds for nets and small ones for the input crystal:","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"package require pbctools\n\ndisplay projection orthographic  # orthographic makes it easier to see the symmetries\n\nproc reset_viz {molid} {\n  # operate only on existing molecules\n  if {[lsearch [molinfo list] $molid] >= 0} {\n    # delete all representations\n    set numrep [molinfo $molid get numreps]\n    for {set i 0} {$i < $numrep} {incr i} {\n      mol delrep $i $molid\n    }\n    # add new representations\n    mol color Element  # color each atom according to its element\n    set name [molinfo $molid get name]\n    if {[regexp {.*net.*\\.vtf} $name] || [regexp {.*clusters.*\\.vtf} $name]} {\n        mol representation CPK 1.2 0.6  # for nets: big spheres\n    } elseif {[regexp {.*\\.vtf} $name]} {\n        mol representation CPK 0.6 0.2  # for input: small spheres\n    }\n    mol selection all\n    mol addrep $molid\n    pbc box  # add the unit cell\n  }\n}\n\nproc reset_viz_proxy {args} {\n  foreach {fname molid rw} $args {}\n  eval \"after idle {reset_viz $molid}\"\n}\n\ntrace variable vmd_initialize_structure w reset_viz_proxy\n\n#color Element C black  # uncomment to have carbon atoms in black\n\nafter idle { reset_viz 0 }","category":"page"},{"location":"man/visualization/#An-example","page":"Visualization","title":"An example","text":"","category":"section"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"DocTestSetup = quote\n    using CrystalNets\n    CrystalNets.toggle_warning(true)\n    CrystalNets.toggle_export(true)\nend\nDocTestFilters = r\"saving file at .*\\_IM\\-19\\_[0-9]+\\.vtf\"","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"Let's consider IM-19 as an example of crystalline framework we are studying. A CIF file for this structure (available from Chaplais et. al. on the CSD) can be accessed at:","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"julia> path_to_im19 = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"IM-19.cif\");","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"Determining its topology yields the following:","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"julia> determine_topology(path_to_im19; bonding=Bonding.Guess, structure=StructureType.MOF)\n[ Info: Initial pass found O and C with invalid number of bonds.\nExport of input is enabled: saving file at /tmp/input_IM-19_0.vtf\nExport of subnet_AllNodes is enabled: saving file at /tmp/subnet_AllNodes_IM-19_0.vtf\nExport of subnet_SingleNodes is enabled: saving file at /tmp/subnet_SingleNodes_IM-19_0.vtf\nAllNodes: rna\nSingleNodes: bpq","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"DocTestSetup = nothing\nDocTestSetup = begin\n    using CrystalNets\n    import CrystalNets: Options, Clustering, Bonding, StructureType\n    const PeriodicGraphs = CrystalNets.PeriodicGraphs\n    using .PeriodicGraphs\n\n    CrystalNets.toggle_export(false)\n    CrystalNets.toggle_warning(false)\nend\nDocTestFilters = nothing","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"Although not necessary, we manually specified bonding=Bonding.Guess to avoid the following warning","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"[ Warning: Guessing bonds with custom algorithm (from Chemfiles and VMD). This may take a while for big structures and may be inexact.\n[ Info: To avoid guessing bonds, use a file format that contains the bonds.","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"The first line of the output is an information about atoms with initial number of bonds. Note that there is no subsequent warning of the form","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"[ Warning: After attempted fix, found remaining C with invalid number of bonds.","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"which indicates that the problem has been internally resolved. It might be good to manually check whether the guessed bonds make sense, as an extra precaution.","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"To do so, simply open VMD and load the VTF file corresponding to the input. On Ubuntu, the following shell command can be used:","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"vmd /tmp/input_IM-19_0.vtf","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"The result will look like this: (Image: IM-19 visualization in VMD)","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"To visualize the \"single nodes\" clusters on top of the input, navigate to File -> New Molecule... in the VMD window and load the adequate VTF file (in our case, the one located at /tmp/subnet_SingleNodes_IM-19_0.vtf). The result should look like this: (Image: IM-19 with single nodes clusters superposed)","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"To look at the underlying topology only (in our case, the bpq net), you can toggle off the visualization of the input file by double-clicking on the D letter left to the input file name in the main VMD window. The result should look like this: (Image: bpq net underlying IM-19)","category":"page"},{"location":"man/visualization/#Export-options","page":"Visualization","title":"Export options","text":"","category":"section"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"There are several export options bundled with CrystalNets.jl, documented in the Options. Each of them can be given as keyword arguments to all functions accepting an Options argument, like determine_topology.","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"The value of the keyword argument can be either","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"a String representing the path of the directory in which to put the exported file. If empty, this disables the export.\na Bool: if true, equivalent to tempdir(); if false, disables the export.","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"The two exports whose default value is defined by CrystalNets.toggle_export are:","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"export_input for the parsed structure.\nexport_subnets for each subnet, defined after clustering and separated into connected components.","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"Other available export options are disabled by default:","category":"page"},{"location":"man/visualization/","page":"Visualization","title":"Visualization","text":"export_trimmed for the trimmed parsed structure. \"Trimming\" refers to removing all atoms that have strictly less than three neighbours and bonding those neighbours together, and so iteratively until no atom remains with strictly less than three neighbours.\nThis export can be useful for debugging since the clustering algorithm runs on the trimmed input, or to remove simple solvent molecules.\nexport_attributions for the classes of the atoms, as defined by the clustering algorithm. This is exported as a PDB file, which can also be natively read by VMD: to see the attributions, switch to \"Type\" for the coloring method instead of \"Element\".\nexport_clusters for the clusters. The only difference with export_subnets is that the graph induced by the clusters is not trimmed yet.\nexport_net for the net before separation into connected components. This is equivalent to catenating the result of export_subnets into a single file.","category":"page"},{"location":"man/clustering/","page":"Clustering options","title":"Clustering options","text":"TBD","category":"page"},{"location":"man/clustering/","page":"Clustering options","title":"Clustering options","text":"In the meantime, check the Clustering information on the different available options.","category":"page"},{"location":"lib/public/#Main-types","page":"Public","title":"Main types","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"CrystalNet\nUnderlyingNets\nTopologicalGenome\nTopologyResult","category":"page"},{"location":"lib/public/#CrystalNets.CrystalNet","page":"Public","title":"CrystalNets.CrystalNet","text":"CrystalNet{D,T<:Real}\n\nRepresentation of a net as a topological abstraction of a crystal.\n\nD is the dimensionality of the net, which is the number of repeated dimensions of a single connex component. This dimensionality is not necessarily the dimension of the space the crystal is embedded into, which would always be 3 for real space.\n\nT is the numeric type used to store the exact coordinates of each vertex at the equilibrium placement.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystalNets.UnderlyingNets","page":"Public","title":"CrystalNets.UnderlyingNets","text":"UnderlyingNets\n\nGrouping of the connected components of a structure according to their dimensionality.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystalNets.TopologicalGenome","page":"Public","title":"CrystalNets.TopologicalGenome","text":"TopologicalGenome\n\nA topological genome computed by CrystalNets.jl.\n\nStore both the actual genome (as a PeriodicGraph) and the name of the net, if recognized.\n\nLike for a PeriodicGraph, the textual representation of a TopologicalGenome can be parsed back into a TopologicalGenome:\n\njulia> topology = topological_genome(CrystalNet(PeriodicGraph(\"2  1 2 0 0  2 1 0 1  2 1 1 0\")))\nhcb\n\njulia> typeof(topology)\nTopologicalGenome\n\njulia> topology.genome  # The actual topological genome, as a PeriodicGraph\nPeriodicGraph2D(2, PeriodicEdge2D[(1, 2, (-1,0)), (1, 2, (0,0)), (1, 2, (0,1))])\n\njulia> parse(TopologicalGenome, \"hcb\") == topology\ntrue\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystalNets.TopologyResult","page":"Public","title":"CrystalNets.TopologyResult","text":"TopologyResult\n\nThe result of a topology computation on a structure with different Clustering options.\n\nIts representation includes the name of the clustering options along with their corresponding genome. It is omitted if there is only one clustering option which is Auto.\n\nLike for a TopologicalGenome (or a PeriodicGraph), the textual representation of a TopologyResult can be parsed back to a TopologyResult:\n\njulia> mof5 = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"MOF-5.cif\");\n\njulia> topologies = determine_topology(mof5, structure=StructureType.MOF, clusterings=[Clustering.Auto, Clustering.Standard, Clustering.PE])\nAllNodes, SingleNodes: pcu\nStandard: xbh\nPE: cab\n\njulia> typeof(topologies)\nTopologyResult\n\njulia> parse(TopologyResult, repr(topologies)) == topologies\ntrue\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Main-functions","page":"Public","title":"Main functions","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"determine_topology\ndetermine_topology_dataset\nguess_topology\nguess_topology_dataset\nparse_chemfile\ntopological_genome\nrecognize_topology","category":"page"},{"location":"lib/public/#CrystalNets.determine_topology","page":"Public","title":"CrystalNets.determine_topology","text":"determine_topology(path, options::Options)\ndetermine_topology(path; kwargs...)\n\nCompute the topology of the structure described in the file located at path. This is essentially equivalent to calling topological_genome(UnderlyingNets(parse_chemfile(path, options))).\n\nIn the case where the structure is not made of interpenetrating nets, return the topology of the only net.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.determine_topology_dataset","page":"Public","title":"CrystalNets.determine_topology_dataset","text":"determine_topology_dataset(path, save, autoclean, options::Options)\ndetermine_topology_dataset(path, save=true, autoclean=true; kwargs...)\n\nGiven a path to a directory containing structure input files, compute the topology of each structure within the directory. Return a dictionary linking each file name to the result. The result is a TopologyResult, containing the topological genome, the name if known and the stability of the net. In case of error, the exception is reported.\n\nIt is strongly recommended to toggle warnings off (through toggle_warning) and not to export any file since those actions may critically reduce performance, especially for numerous files.\n\nIf save is set, the result is also stored in a julia serialized file located at \"$path/../results_$i\" where i is the lowest integer such that this path does not already exist at the start of the computation. While processing, this path will be used to create a directory storing the current state of the computation: to continue an interrupted computation, simply pass this temporary directory as the path. If autoclean is set, this directory is removed at the end if the computation was successful.\n\nIf save is set and autoclean is unset, the directory of temporary files will be renamed into \"$path/../results_$i.OLD$j\".\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.guess_topology","page":"Public","title":"CrystalNets.guess_topology","text":"guess_topology(path, options::Options)\nguess_topology(path; kwargs...)\n\nTries to determine the topology of the file at path by passing various options (starting from the provided options if any) until finding a known topology. If none is found, return the topological genome encountered most often through the variation of options.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.guess_topology_dataset","page":"Public","title":"CrystalNets.guess_topology_dataset","text":"guess_topology_dataset(path, save, autoclean, options::Options)\nguess_topology_dataset(path, save=true, autoclean=true; kwargs...)\n\nGiven a path to a directory containing structure input files, guess the topology of each structure within the directory using guess_topology. Return a dictionary linking each file name to the result. The result is the corresponding topology name, if known, or the topological genome preceded by an \"UNKNOWN\" mention otherwise. In case of error, the result is the exception preceded by a \"FAILED with\" mention. Finally, if the input does not represent a periodic structure, the result is \"non-periodic\".\n\nIt is strongly recommended to toggle warnings off (through toggle_warning) and not to export any file since those actions may critically reduce performance, especially for numerous files.\n\nThe save and autoclean arguments work identically to their counterpart for determine_topology_dataset.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.parse_chemfile","page":"Public","title":"CrystalNets.parse_chemfile","text":"   parse_chemfile(path, options::Options)\n   parse_chemfile(path; kwargs...)\n\nParse a file given in any recognised chemical format and extract the topological information. Such format can be .cif or any file format recognised by Chemfiles.jl that contains all the necessary topological information.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.topological_genome","page":"Public","title":"CrystalNets.topological_genome","text":"topological_genome(net::CrystalNet{D,T})::String where {D,T}\n\nCompute the topological genome of a net. The topological genome is an invariant if the net, meaning that it does not depend on its representation. It is also the string representation of a D-periodic graph such that PeriodicGraph{D}(topological_genome(net)) is isomorphic to net.graph (except possibly if the ignore_types option is unset).\n\ninfo: Info\nOptions must be passed directly within net.\n\n\n\n\n\ntopological_genome(g::Union{String,PeriodicGraph}, options::Options=Options())\ntopological_genome(g::Union{String,PeriodicGraph}; kwargs...)\n\nCompute the topological genome of a periodic graph. If given a topological key (as a string), it is converted to a PeriodicGraph first.\n\n\n\n\n\ntopological_genome(group::UnderlyingNets)::Vector{Tuple{Vector{Int},String}}\n\nCompute the topological genome of each subnet stored in group.\n\ninfo: Info\nOptions must be passed directly within the subnets.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.recognize_topology","page":"Public","title":"CrystalNets.recognize_topology","text":"recognize_topology(g::PeriodicGraph, arc=CRYSTAL_NETS_ARCHIVE)\nrecognize_topology(genome::AbstractString, arc=CRYSTAL_NETS_ARCHIVE)\n\nAttempt to recognize a topological genome from an archive of known genomes.\n\nwarning: Warning\nThis function does a simple lookup, not any kind of topology computation. To identify the topology of a PeriodicGraph or a CrystalNet x, query topological_genome(x) instead.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Options","page":"Public","title":"Options","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"CrystalNets.Options\nStructureType\nBonding\nClustering\nClusterKinds","category":"page"},{"location":"lib/public/#CrystalNets.Options","page":"Public","title":"CrystalNets.Options","text":"Options\n\nDifferent options, passed as keyword arguments.\n\nBasic options\n\nname: a name for the structure.\nbonding: one of the Bonding options. Default is Bonding.Auto.\nstructure: one of the StructureType options. Default is StructureType.Auto.\nclusterings: a list of Clustering options. Default is [Clustering.Auto].\n\nExports\n\nFor each export option, the accepted values are either a string, indicating the path to the directory in which to store the export, or a boolean, specifying whether or not to do the export. If the value is true, a path will be automatically determined. An empty string is equivalent to false.\n\nexport_input: the parsed structure, as a .vtf\nexport_trimmed: the parsed structure after iteratively removing all atoms having only one neighbour, as a .vtf\nexport_attributions: the attribution of vertices into SBUs, as a .pdb. Only relevant for the MOF StructureType.\nexport_clusters: the clustering of vertices, as a .vtf\nexport_net: the overall extracted net on which the topology is computed, as a .vtf.\nexport_subnets: each connected component of the overall net as a separate .vtf file. These subnets are defined after grouping vertices according to their Clustering.\n\nOther options\n\nignore_atoms: set of atom symbols to ignore (for instance [:C,:H] will remove carbohydrate solvent residues).\nignore_types: disregard atom types to compute the topology, making pcu and pcu-b identical for example (default is true)\ncutoff_coeff: coefficient used to detect bonds. Default is 0.75, higher values will include bonds that were considered too long before.\nskip_minimize: assume that the cell is already the unit cell (default is false).\ndimensions: the set of crystal net dimensions to consider. For instance, putting Set(3) will ensure that only 3-dimensional nets are considered. Default is Set([1,2,3]).\ncluster_kinds: a ClusterKinds. Default separates organic and inorganic SBUs.\nignore_homoatomic_bonds: a Set{Symbol} such that all X-X bonds of the net are removed if X is an atom whose type is in ignore_homoatomic_bonds.\nmax_polyhedron_radius: an integer specifying the maximum number of bonds between two corners of the coordination polyhedron built for the Clustering.PE option. Default is 4.\n\nMiscellaneous options\n\nThese boolean options have a default value that may be determined by Bonding, StructureType and Clustering. They can be directly overriden here.\n\nbond_adjacent_sbus: bond together SBUs which are only separated by a single C atom.\nauthorize_pruning: remove colliding atoms in the input. Default is true.\nwider_metallic_bonds: for bond detections, metals have a radius equal to 1.5× their Van der Waals radius. Default is false, unless StructureType is MOF or Zeolite.\nignore_homometallic_bonds: do not bond two metallic atoms of the same type if they are up to third neighbours anyway. Default is false, unless StructureType is MOF.\nignore_metal_cluster_bonds: do not bond two metallic clusters together if they share at least one non-metallic neighbour. Default is false.\nignore_low_occupancy: atoms with occupancy lower than 0.5 are ignored. Default is false.\ndetect_paddlewheels: detect paddle-wheel pattern and group them into an inorganic vertex. Default is true.\ndetect_organiccycles: detect organic cycles and collapse all belonging C atoms into a new vertex. Default is true.\ndetect_pe: detect organic points-of-extension (organic atoms bonded to another SBU) and transform them into vertices. Default is true.\ncluster_simple_pe: cluster adjacent points-of-extension if they are not part of a cycle. Default is true.\nseparate_metals: separate each metal atom into its own vertex (instead of grouping them to form metallic clusters if they are adjacent or bonded by an oxygen). Default is false, unless Clustering is Standard or PEM.\nsplit_O_vertex: if a vertex is composed of a single O, remove it and bond together all of its neighbors. Default is true.\nunify_sbu_decomposition: apply the same rule to decompose both periodic and finite SBUs. Default is false.\nforce_warn: force printing warning and information even during ..._dataset and ..._topologies function calls. Default is false.\n\nInternal fields\n\nThese fields are for internal use and should not be modified by the user:\n\ndryrun: store information on possible options to try (for guess_topology).\n_pos: the positions of the centre of the clusters collapsed into vertices.\nerror: store the first error that occured when building the net.\nthrow_error: if set, throw the error instead of storing it in the error field.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystalNets.StructureType","page":"Public","title":"CrystalNets.StructureType","text":"StructureType\n\nSelection mode for the crystal structure. This choice impacts the bond detection algorithm as well as the clustering algorithm used.\n\nThe choices are:\n\nAuto: No specific structure information. Use Van der Waals radii for bond detection and Input as Clustering, or EachVertex if the input does not provide residues.\nMOF: Use Van der Waals radii for non-metallic atoms and larger radii for metals. Detect organic and inorganic clusters and subdivide them according to AllNodes and SingleNodes to identify underlying nets.\nCluster: similar to MOF but metallic atoms are not given a wider radius.\nZeolite: Same as Auto but use larger radii for metals (and metalloids) and attempt to enforce that each O atom has exactly two neighbours and that they are not O atoms.\nGuess: try to identify the clusters as in Cluster. If it fails, fall back to Auto.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CrystalNets.Bonding","page":"Public","title":"CrystalNets.Bonding","text":"Bonding\n\nSelection mode for the detection of bonds. The choices are:\n\nInput: use the input bonds. Fail if those are not specified.\nGuess: guess bonds using a variant of chemfiles / VMD algorithm.\nAuto: if the input specifies bonds, use them unless they look suspicious (too small or or too large according to a heuristic). Otherwise, fall back to Guess.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CrystalNets.Clustering","page":"Public","title":"CrystalNets.Clustering","text":"Clustering\n\nThe clustering algorithm used to group atoms into vertices.\n\nThis choice only affects the creation of a UnderlyingNets from a Crystal, not the Crystal itself, and in particular not the bond detection algorithm.\n\nThe basic choices are:\n\nAuto: determined using the StructureType.\nInput: use the input residues as vertices. Fail if some atom does not belong to a residue.\nEachVertex: each atom is its own vertex. Vertices with degree 2 or lower are iteratively collapsed into edges until all vertices have degree 3 or more.\n\nThe next clustering options are designed for MOFs but may target other kinds of frameworks. In all cases, the clusters are refinements on top of already-defined clusters, such as the organic and inorganic SBUs defined by the MOF structure. Except for AllNodes, infinite clusters (such as the inorganic clusters in a rod MOF) are split into new finite clusters using heuristics.\n\nSingleNodes: each already-defined cluster is mapped to a vertex.\nAllNodes: keep points of extension for organic clusters.\nStandard: make each metallic atom its own vertex and do not bond those together if they share a common non-metallic neighbour.\nPE: stands for Points of Extension. Keep points of extension for organic clusters, remove metallic centres and bond their surrounding points of extension.\nPEM: stands for Points of Extension and Metals. Keep points of extension for organic clusters and each metal centre as a separate vertex.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CrystalNets.ClusterKinds","page":"Public","title":"CrystalNets.ClusterKinds","text":"ClusterKinds(sbus, toclassify=Int[])\n\nDescription of the different kinds of SBUs there should be when making clusters.\n\nsbus should be a list of set of symbols, each set containing the different elements acceptable in this SBU (an empty set designates all remaining elements). All elements of the same category of the periodic table can be grouped together by putting the name of the category. For example, ClusterKinds([[:Au, :halogen, :nonmetal], [:metal, :metalloid], []]) means that there are three kinds of SBUs:\n\nthe first kind can only hold halogens, non-metals and Au atoms\nthe second kind can only hold metalloids and metals (except Au)\nthe third kind can hold all the other elements.\n\nThe list of possible categories is: :actinide, :noble (for noble gas), :halogen, :lanthanide, :metal, :metalloid and :nonmetal.\n\ntoclassify contains the list of SBUs which are not actual SBUs but only groups of atoms waiting to be merged to a neighboring SBU. The neighboring SBU is chosen by order in the sbus list.\n\nThe cluster kinds used by default are CrystalNets.ClusterKinds([[:metal, :actinide, :lanthanide], [:C,], [:P, :S],                            [:nonmetal, :metalloid, :halogen], [:noble]], [3, 4]). This means that all atoms that are either metals, actinides or lanthanides are assigned to class 1 and all C atoms in SBUs of class 2. Afterwards, each group of adjacent P or S atoms is assigned either class 1 if any of its neighbor is of class 1, or class 2 otherwise if any of its neighbor is of class 2. If no such neighbor exist, it is assigned to class 1. Finally, each group of adjacent nonmetals, metalloids and halogens is assigned class 1 or 2 following the same rule as for P and S atoms.\n\nAt the end of the procedure, all atoms are thus given a class between 1 and length(sbus) which is not in toclassify. See also find_sbus for the implementation of this procedure.\n\nTo determine which SBU kind corresponds to a given atom, use getindex:\n\njulia> sbu_kinds = CrystalNets.ClusterKinds([[:nonmetal, :halogen], [:metal, :F]]);\n\njulia> sbu_kinds[:O] # nonmetal\n1\n\njulia> sbu_kinds[:Au] # metal\n2\n\njulia> sbu_kinds[:F] # specifically F\n2\n\njulia> sbu_kinds[:Ne] # no given SBU kind\n0\n\nIf no empty set has been explicitly added to sbus and an element falls outside of the included categories, the returned SBU kind is 0.\n\nAn exception is made for nonmetals which are part of an aromatic heterocycle: those will be treated separately and put in the SBU of the corresponding carbons.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Archive","page":"Public","title":"Archive","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"REVERSE_CRYSTAL_NETS_ARCHIVE\nCrystalNets.parse_arc\nCrystalNets.parse_arcs\nclean_default_archive!\nset_default_archive!\nempty_default_archive!\nchange_current_archive!\nrefresh_current_archive!\nadd_to_current_archive!\nmake_archive\nCrystalNets.export_arc","category":"page"},{"location":"lib/public/#CrystalNets.REVERSE_CRYSTAL_NETS_ARCHIVE","page":"Public","title":"CrystalNets.REVERSE_CRYSTAL_NETS_ARCHIVE","text":"const REVERSE_CRYSTAL_NETS_ARCHIVE::Dict{String,String}\n\nReverse of CRYSTAL_NETS_ARCHIVE.\n\nCan be used to query the topological genome of known nets, as in:\n\njulia> REVERSE_CRYSTAL_NETS_ARCHIVE[\"dia\"]\n\"3 1 2 0 0 0 1 2 0 0 1 1 2 0 1 0 1 2 1 0 0\"\n\njulia> topological_genome(CrystalNet(PeriodicGraph(ans)))\ndia\n\nnote: Note\nIt is also possible to directly access the topological genome as a PeriodicGraph by parsing the name as a TopologicalGenome:julia> parse(TopologicalGenome, \"pcu\").genome\nPeriodicGraph3D(1, PeriodicEdge3D[(1, 1, (0,0,1)), (1, 1, (0,1,0)), (1, 1, (1,0,0))])\n\njulia> string(parse(TopologicalGenome, \"nbo\").genome) == REVERSE_CRYSTAL_NETS_ARCHIVE[\"nbo\"]\ntrue\n\n\n\n\n\n","category":"constant"},{"location":"lib/public/#CrystalNets.parse_arc","page":"Public","title":"CrystalNets.parse_arc","text":"parse_arc(file)\n\nParse a .arc Systre archive such as the one used by the RCSR. Return a pair (flag, pairs).\n\nflag is set if the archive corresponds to one generated by a compatible release of CrystalNets. If unset, the genomes of the archive may not be the same as those computed by CrystalNets for the same nets. pairs is a Dict{String,String} whose entries have the form genome => id where id is the name of the net and genome is the topological genome corresponding to this net (given as a string of whitespace-separated values parseable by PeriodicGraph).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.parse_arcs","page":"Public","title":"CrystalNets.parse_arcs","text":"parse_arcs(file)\n\nParse a folder containing .arc Systre archives such as the one used by the RCSR. Return a pair (flag, pairs) with the same convention than parse_arc.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.clean_default_archive!","page":"Public","title":"CrystalNets.clean_default_archive!","text":"clean_default_archive!(custom_arc; validate=true, refresh=true)\n\nErase the default archive used by CrystalNets.jl to recognize known topologies and replace it with a new one from the file located at custom_arc.\n\nThe validate parameter controls whether the new file is checked and converted to a format usable by CrystalNets.jl. If unsure, leave it set.\n\nThe refresh optional parameter controls whether the current archive should be replaced by the new default one.\n\nwarning: Warning\nThis archive will be kept and used for subsequent runs of CrystalNets.jl, even if you restart your Julia session.To only change the archive for the current session, use change_current_archive!(custom_arc).See also refresh_current_archive! for similar uses.\n\nwarning: Warning\nThe previous default archive cannot be recovered afterwards, so make sure to keep a copy if necessary. The default archive is the set of \".arc\" files located at joinpath(dirname(dirname(pathof(CrystalNets))), \"archives\").\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.set_default_archive!","page":"Public","title":"CrystalNets.set_default_archive!","text":"set_default_archive!()\n\nSet the current archive as the new default archive.\n\nwarning: Warning\nThis archive will be kept and used for subsequent runs of CrystalNets.jl, even if you restart your Julia session.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.empty_default_archive!","page":"Public","title":"CrystalNets.empty_default_archive!","text":"empty_default_archive!(; refresh=true)\n\nEmpty the default archive. This will prevent CrystalNets from recognizing any topology before they are explicitly added.\n\nThe refresh optional parameter controls whether the current archive should also be emptied.\n\nwarning: Warning\nThis empty archive will be kept and used for subsequent runs of CrystalNets.jl, even if you restart your Julia session. If you only want to empty the current archive, do empty!(CrystalNets.CRYSTAL_NETS_ARCHIVE).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.change_current_archive!","page":"Public","title":"CrystalNets.change_current_archive!","text":"change_current_archive!(custom_arc; validate=true)\n\nErase the current archive used by CrystalNets.jl to recognize known topologies and replace it with the archive stored in the file located at custom_arc.\n\nThe validate optional parameter controls whether the new file is checked and converted to a format usable by CrystalNets.jl. If unsure, leave it set.\n\nnote: Note\nThis modification will only last for the duration of this Julia session.If you wish to change the default archive and use it for subsequent runs, use clean_default_archive!.\n\nwarning: Warning\nUsing an invalid archive will make CrystalNets.jl unusable. If this happens, simply run refresh_current_archive!() to revert to the default archive.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.refresh_current_archive!","page":"Public","title":"CrystalNets.refresh_current_archive!","text":"refresh_current_archive!()\n\nRevert the current topological archive to the default one.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.add_to_current_archive!","page":"Public","title":"CrystalNets.add_to_current_archive!","text":"add_to_current_archive!(id, genome)\n\nMark genome as the topological genome associated with the name id in the current archive.\n\nThe input id and genome are not modified by this operation.\n\nnote: Note\nThis modification will only last for the duration of this Julia session.If you wish to save the archive and use it for subsequent runs, use set_default_archive! after calling this function.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.make_archive","page":"Public","title":"CrystalNets.make_archive","text":"make_archive(path, destination=nothing)\n\nMake an archive from the files located in the directory given by path and export it to destination, if specified. Each file of the directory should correspond to a unique topology: if a topology is encountered multiple times, it will be assigned the name of the latest file that bore it.\n\nThe archive can then be used with change_current_archive!(destination; validate=false) for instance.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.export_arc","page":"Public","title":"CrystalNets.export_arc","text":"export_arc(path)\n\nExport the current archive to the specified path.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Other-utilities","page":"Public","title":"Other utilities","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"CrystalNets.toggle_warning\nCrystalNets.toggle_export\nCrystalNets.export_default","category":"page"},{"location":"lib/public/#CrystalNets.toggle_warning","page":"Public","title":"CrystalNets.toggle_warning","text":"toggle_warning(to=nothing)\n\nToggle warnings on (if to == true) or off (if to == false). Without an argument, toggle on and off repeatedly at each call.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.toggle_export","page":"Public","title":"CrystalNets.toggle_export","text":"toggle_export(to=nothing)\n\nToggle exports on (if to == true) or off (if to == false). Without an argument, toggle on and off repeatedly at each call.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.export_default","page":"Public","title":"CrystalNets.export_default","text":"export_default(c::Union{PeriodicGraph,CrystalNet,Crystal}, obj=nothing, name=nothing, path=tempdir(); repeats=nothing)\n\nExport a VTF representation of an object at the given path.\n\nobj is a String describing the nature of the object, such as \"net\", \"clusters\" or \"subnet\" for example. Default is string(typeof(c)).\n\nname is a String inserted in the exported file name. Default is a tempname.\n\nrepeats is the maximum distance between a represented atom out of the unit cell and one inside. Default is between 2 and 6, depending on obj and the size of the graph.\n\n\n\n\n\n","category":"function"},{"location":"#CrystalNets.jl","page":"Home","title":"CrystalNets.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CrystalNets.jl is a a Julia package for automatic detection and identification of net topologies underlying crystalline materials. Its inputs can be chemical files in any format recognized by chemfiles.","category":"page"},{"location":"#Package-installation","page":"Home","title":"Package installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The installation follows the usual procedure. Start by downloading and installing Julia (v1.6 or higher for CrystalNets.jl). Then, either","category":"page"},{"location":"","page":"Home","title":"Home","text":"open the Julia REPL and enter the package manager by typing ], then install CrystalNets.jl by entering:  julia  pkg> add CrystalNets\nalternatively, you can do it from a shell by executing:  bash  julia -e 'import Pkg; Pkg.add(\"CrystalNets\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, open a REPL and enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using CrystalNets","category":"page"},{"location":"","page":"Home","title":"Home","text":"or proceed with the Full installation to obtain an executable.","category":"page"},{"location":"#Quick-usage-as-a-module","page":"Home","title":"Quick usage as a module","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To determine the topology of a structure stored in a file at location path, simply call","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> determine_topology(path)","category":"page"},{"location":"#Known-nets","page":"Home","title":"Known nets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If recognized, this yields the name of the net. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> determine_topology(\"/path/to/diamond.cif\")\nExport of input is enabled: saving file at /tmp/input_diamond_0.vtf\nExport of subnet_Auto is enabled: saving file at /tmp/subnet_Auto_diamond_0.vtf\ndia","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, the parsed input and the extracted underlying nets are exported as .vtf files (see Visualization). To toggle on or off automatic exports, use CrystalNets.toggle_export, and similarly with CrystalNets.toggle_warning for warnings.","category":"page"},{"location":"#Unknown-nets","page":"Home","title":"Unknown nets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the net is not recognized, its topological genome is displayed preceded by an \"UNKNOWN\" mention, or \"unstable\" if the net is unstable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> determine_topology(\"/path/to/new/material.cif\")\nUNKNOWN 2 1 2 -2 0 1 2 0 0 1 2 0 1 2 2 1 0\n\njulia> determine_topology(\"/path/to/unstable/net.cif\")\nunstable 1 1 1 1 1 2 0 2 2 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"In both known and unknown cases, the result is a TopologyResult.","category":"page"},{"location":"#Interpenetrating-substructures","page":"Home","title":"Interpenetrating substructures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the file contains multiple interpenetrating substructures, the result is a Vector{Tuple{Vector{Int64}, TopologyResult}}, where each entry is a tuple (vmap, result) with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"vmap: the list of vertices of the initial graph that were kept for this substructure. The initial graph is the one exported in .vtf as input. See also parse_chemfile and CrystalNets.Crystal for manipulations on the initial graph.\nresult: the TopologyResult for this substructure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> determine_topology(\"/path/to/intertwinned/structures.cif\")\n2-element Vector{Tuple{Vector{Int64}, TopologyResult}}:\n ([2, 3, 4, 6], pcu)\n ([1, 5, 7, 8], srs)","category":"page"},{"location":"#Using-options","page":"Home","title":"Using options","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Options can be added as individual keyword arguments to the call. For instance:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> path_to_mof5 = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"MOF-5.cif\");\n\njulia> determine_topology(path_to_mof5; structure=StructureType.MOF,\n                                        clusterings=[Clustering.PE,Clustering.Standard],\n                                        split_O_vertex=false)\nPE: cab\nStandard: fff","category":"page"},{"location":"#Full-installation","page":"Home","title":"Full installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To obtain an executable, CrystalNets.jl can be statically compiled. To do so, run the following julia script after changing the INSTALLATION_PATH variable to the location where the CrystalNets.jl executable will be installed. Note that this requires the PackageCompiler module.","category":"page"},{"location":"","page":"Home","title":"Home","text":"const INSTALLATION_PATH = \"/fill/with/installation/path\"\n\nusing PackageCompiler\nusing CrystalNets\n\nconst root = dirname(dirname(pathof(CrystalNets)))\n\ncreate_app(root, INSTALLATION_PATH; precompile_statements_file=abspath(root, \"src\", \"precompile.jl\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The executable will be located in the \"bin\" subdirectory of the specified INSTALLATION_PATH, under the name \"CrystalNets\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"The executable can then simply be used on a chemical file:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ CrystalNets /path/to/diamond.cif\ndia","category":"page"},{"location":"","page":"Home","title":"Home","text":"Run CrystalNets --help for the list of options available to the executable.","category":"page"},{"location":"faq/#Troubleshooting","page":"Common issues","title":"Troubleshooting","text":"","category":"section"},{"location":"faq/","page":"Common issues","title":"Common issues","text":"TBD","category":"page"},{"location":"faq/","page":"Common issues","title":"Common issues","text":"In the meantime, please report any troube you may have by opening an issue.","category":"page"},{"location":"man/archive/","page":"Custom archive","title":"Custom archive","text":"TDB","category":"page"},{"location":"man/archive/","page":"Custom archive","title":"Custom archive","text":"In the meantime, if you want to use your custom archive, check the functions defined in the Archive section.","category":"page"}]
}
