var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Internal-types-and-functions","page":"Internals","title":"Internal types and functions","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"See also the documentations of PeriodicGraphs.jl and of PeriodicGraphEmbeddings.jl","category":"page"},{"location":"lib/internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.Crystal\nCrystalNets.Clusters\nCrystalNets.CollisionNode\nCrystalNets.CIF","category":"page"},{"location":"lib/internals/#CrystalNets.Crystal","page":"Internals","title":"CrystalNets.Crystal","text":"Crystal\n\nIntermediate representation of a crystal, retaining information on the cell, and the fractional placement of the atoms and their type, as well as the residues which will be used as vertices for the computation of the underlying topology.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#CrystalNets.Clusters","page":"Internals","title":"CrystalNets.Clusters","text":"Clusters\n\nClassification of the atoms of a crystalline framework in different clusters. For simple crystals, every atom is its own cluster. For a MOF, a cluster is a SBU, which can be either organic or inorganic.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#CrystalNets.CollisionNode","page":"Internals","title":"CrystalNets.CollisionNode","text":"CollisionNode\n\nStore information on all contiguous vertices of a graph whose placement collide to the same position.\n\nVertices in a CollisionNode are stored by increasing number of their coordinationn sequences. The subranges field of a CollisionNode contains the sub-ranges of vertices sharing the same coordination sequence, but that could not be determined to be strictly equivalent. Each permutation of such vertices will need be explored.\n\nUse get_CollisionNode to create a CollisionNode from a graph and a range of colliding vertices. This will also return a vmap to be applied to the graph for the representation to be consistent. Two CollisionNodes can be compared to check if they could possibly be topologically equivalent using possibly_equivalent_nodes\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#CrystalNets.CIF","page":"Internals","title":"CrystalNets.CIF","text":"CIF\n\nRepresentation of a .cif file.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Core-topology-functions","page":"Internals","title":"Core topology functions","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.topological_key\nCrystalNets.CRYSTALNETS_ARCHIVE\nCrystalNets.minimize\nCrystalNets.candidate_key\nCrystalNets.possible_translations\nCrystalNets.find_all_valid_translations\nCrystalNets.minimal_volume_matrix\nCrystalNets.reduce_with_matrix\nCrystalNets.partition_by_coordination_sequence\nCrystalNets.find_candidates\nCrystalNets.extract_through_symmetry\nCrystalNets.find_initial_candidates\nCrystalNets.find_candidates_onlyneighbors\nCrystalNets.find_candidates_fallback","category":"page"},{"location":"lib/internals/#CrystalNets.topological_key","page":"Internals","title":"CrystalNets.topological_key","text":"topological_key(net::CrystalNet)\n\nReturn a unique topological key for the net, which is a topological invariant of the net (i.e. it does not depend on its initial representation).\n\nwarning: Warning\nBeware that no cell minimization will be attempted. Thus, if the net is not in a minimal unit cell, the result will be meaningless.\n\nFor most non-internal purposes, topological_genome should be called instead.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.CRYSTALNETS_ARCHIVE","page":"Internals","title":"CrystalNets.CRYSTALNETS_ARCHIVE","text":"const CRYSTALNETS_ARCHIVE::Dict{String,String}\n\nThe archive used to recognize known topologies.\n\nYou probably don't need to access it directly: rely on recognize_topology to read and the various archive functions like add_to_current_archive! to write.\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#CrystalNets.minimize","page":"Internals","title":"CrystalNets.minimize","text":"minimize(net::CrystalNet, [collisionsetup])\n\nReturn a CrystalNet representing the same net as the input, but in a unit cell. If collisionsetup is given, also return the corresponding collisions after minimization.\n\nThe computed unit cell may depend on the representation of the input, i.e. it is not topologicallly invariant.\n\n\n\n\n\nminimize(net::Crystal{Nothing})\n\nReturn a Crystal representing the same crystal as the input, but in a unit cell.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.candidate_key","page":"Internals","title":"CrystalNets.candidate_key","text":"candidate_key(net::CrystalNet, u, basis, minimal_edgs)\n\nGiven the net, a candidate u => basis where u is the origin and basis the triplet of axes, and minimal_edgs the last minimal key (for the pseudo-lexicographical order used), extract the key corresponding to the current candidate.\n\nThe key is the lexicographically ordered list of edges of the graph when its vertices are numbered according to the candidate. The ordering of keys first compares the list of edges disregarding the offsets, and then only compares the offsets if the rest is identical.\n\nIf the key is larger or equal to minimal_edgs, early stop and return two empty lists. Otherwise, the extracted key is the current best: return the vmap between the initial vertices and their ordered image in the candidate, as well as the key.\n\nSee also: find_candidates\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.possible_translations","page":"Internals","title":"CrystalNets.possible_translations","text":"possible_translations(c::Union{CrystalNet,CrystalNet})\n\nReturn a list of tuples (nz, i_max_den, max_den, t) where\n\nt is a translation mapping at the origin vertex to another one in the unit cell.\nmax_den is the maximum denominator in the D coefficients of t.\ni_max_den is the index.\nnz is the number of zeros in t.\n\nThe list is guaranteed to contain all the possible valid translations but may contain some invalid translations.\n\nSee also: find_all_valid_translations, PeriodicGraphEmbeddings.check_valid_symmetry\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.find_all_valid_translations","page":"Internals","title":"CrystalNets.find_all_valid_translations","text":"find_all_valid_translations(net::CrystalNet{D}) where D\n\nReturn a D-tuple of list of tuples (i_max_den, max_den, t) (see possible_translations for interpretation) where the n-th list contains all valid translations of the net having exactly n-1 zeros.\n\nA translation is valid if it maps exactly each vertex to a vertex and each edge to an edge.\n\nSee also: possible_translations, PeriodicGraphEmbeddings.check_valid_symmetry\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.minimal_volume_matrix","page":"Internals","title":"CrystalNets.minimal_volume_matrix","text":"minimal_volume_matrix(translations::NTuple{D}) where {D}\n\nGiven the output of find_all_valid_translations, compute the transformation that allows reducing the net to its minimal cell.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.reduce_with_matrix","page":"Internals","title":"CrystalNets.reduce_with_matrix","text":"reduce_with_matrix(c::CrystalNet, mat)\n\nGiven the net and the output of minimal_volume_matrix computed on the valid translations of the net, return the new net representing the initial net in the computed unit cell.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.partition_by_coordination_sequence","page":"Internals","title":"CrystalNets.partition_by_coordination_sequence","text":"partition_by_coordination_sequence(graph, symmetries::AbstractSymmetryGroup=NoSymmetryGroup(graph))\n\nPartition the vertices of the graph into disjoint categories, one for each coordination sequence. The partition is then sorted by order of coordination sequence. This partition does not depend on the representation of the graph. The optional argument vmaps is a set of permutations of the vertices that leave the graph unchanged. In other words, vmaps is a set of symmetry operations of the graph.\n\nReturn the categories and a list of unique representative for each symmetry class.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.find_candidates","page":"Internals","title":"CrystalNets.find_candidates","text":"find_candidates(net::CrystalNet{D}, hascollisions) where D\n\nReturn a non-empty set of candidates u => basis where u is a vertex and basis is matrix whose columns are D linearly independent euclidean embeddings of edges. The returned set is independent of the representation of the graph used in net.\n\nAlso return a category_map linking each vertex to its category number, as defined by partition_by_coordination_sequence\n\nSee also: candidate_key\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.extract_through_symmetry","page":"Internals","title":"CrystalNets.extract_through_symmetry","text":"extract_through_symmetry(candidates::Dict{Int,Vector{SMatrix{3,3,T,9}}}, symmetries::AbstractSymmetryGroup) where T\n\nGiven the candidates and the list of symmetries of the net, return the flattened list of candidates after removing candidates that are symmetric images of the kept ones.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.find_initial_candidates","page":"Internals","title":"CrystalNets.find_initial_candidates","text":"find_initial_candidates(net::CrystalNet{D}, candidates_v, category_map) where D\n\nGiven the net, a list of vertices in a given category and the category_map, return a list of pairs u => (basis, cats) where u ∈ candidates_v, basis is a D-rank matrix made by juxtaposing the euclidean embeddings of outgoing edges from u, and cats are the categories of the respective neighbors of u.\n\nIf the basis corresponding to vertex u is not of rank D, it is not included in the returned list (for instance, if all outgoing edges of a vertex are coplanar with D == 3).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.find_candidates_onlyneighbors","page":"Internals","title":"CrystalNets.find_candidates_onlyneighbors","text":"find_candidates_onlyneighbors(net::CrystalNet{D}, candidates_v, category_map) where D\n\nGiven the net, a list of vertices in a given category and the category_map, return a Dict whose pairs u => matv are such that u ∈ candidates_v and matv is a list of unique invertible matrices of size D whose columns are euclidean embeddings of outgoing edges from u. Each such matrix has a category, defined by the D-uplet of categories of each corresponding outneighbor of u: the returned Dict is such that all the matrices belonging to all matv share the same category.\n\nThe returned Dict is empty iff find_initial_candidates(net, candidates_v, category_map) is empty.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.find_candidates_fallback","page":"Internals","title":"CrystalNets.find_candidates_fallback","text":"find_candidates_fallback(net::CrystalNet3D, reprs, othercats, category_map)\n\nReturn candidates in the same form as find_candidates_onlyneighbors except that only two edges start from u and one does not.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Input","page":"Internals","title":"Input","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.parse_cif\nCrystalNets.CIF(file_path::AbstractString)\nCrystalNets.check_collision\nCrystalNets.fix_atom_on_a_bond!\nCrystalNets.least_plausible_neighbours\nCrystalNets.fix_valence!\nCrystalNets.sanitize_removeatoms!\nCrystalNets.remove_triangles!\nCrystalNets.remove_homoatomic_bonds!\nCrystalNets.sanity_checks!","category":"page"},{"location":"lib/internals/#CrystalNets.parse_cif","page":"Internals","title":"CrystalNets.parse_cif","text":"parse_cif(file_path)\n\nParse a CIF file and return a dictionary where each identifier (without the starting '_' character) is linked to its value. Values are either a string or a vector of string (if defined in a loop).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.CIF-Tuple{AbstractString}","page":"Internals","title":"CrystalNets.CIF","text":"CIF(file_path::AbstractString)\n\nMake a CIF object out of the parsed file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#CrystalNets.check_collision","page":"Internals","title":"CrystalNets.check_collision","text":"check_collision(pos, mat)\n\nGiven a list of fractional coordinates pos and the matrix of the unit cell mat, return a list of atoms that are suspiciously close to another atom of the list. For each collision site, only one atom is not present in the returned list.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.fix_atom_on_a_bond!","page":"Internals","title":"CrystalNets.fix_atom_on_a_bond!","text":"fix_atom_on_a_bond!(graph, pos, mat)\n\nRemove bonds that are intercepted by an atom.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.least_plausible_neighbours","page":"Internals","title":"CrystalNets.least_plausible_neighbours","text":"least_plausible_neighbours(Δs, n)\n\nFind the positions of the n least probable neighbours of an atom, given the list Δs of the distance between their position and that of the atom.\n\nThis function is highly empirical and should not be considered utterly reliable.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.fix_valence!","page":"Internals","title":"CrystalNets.fix_valence!","text":"fix_valence!(graph::PeriodicGraph3D, pos, types, passH, passO, passCN, mat, ::Val{dofix}, options) where {dofix}\n\nAttempt to ensure that the coordinence of certain atoms are at least plausible by removing some edges from the graph. These atoms are H, halogens, O, N and C. if dofix is set, actually modify the graph; otherwise, only emit a warning. In both cases, return a list of atoms with invalid coordinence.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.sanitize_removeatoms!","page":"Internals","title":"CrystalNets.sanitize_removeatoms!","text":"sanitize_removeatoms!(graph::PeriodicGraph3D, pos, types, mat, options)\n\nSpecial heuristics to remove atoms that seem to arise from an improper cleaning of the file. Currently implemented:\n\nC atoms suspiciously close to metallic atoms.\nOne of two identical metallic atoms suspiciously close to one another\n\nTODO:\n\nO atoms with 4 coplanar bonds (warning only).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.remove_triangles!","page":"Internals","title":"CrystalNets.remove_triangles!","text":"remove_triangles!(graph::PeriodicGraph3D, pos, types, mat, toinvestigate=collect(edges(graph)))\n\nIn a configuration where atoms A, B and C are pairwise bonded, remove the longest of the three bonds if it is suspicious (too large and too close to the third atom).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.remove_homoatomic_bonds!","page":"Internals","title":"CrystalNets.remove_homoatomic_bonds!","text":"remove_homoatomic_bonds!(graph::PeriodicGraph, types, targets, reduce_homometallic)\n\nRemove from the graph all bonds of the form X-X where X is an atom in targets.\n\nAlso remove all such bonds where X is a metal if the two bonded atoms up to third neighbours otherwise, and if reduce_homometallic is true.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.sanity_checks!","page":"Internals","title":"CrystalNets.sanity_checks!","text":"sanity_checks!(graph, pos, types, mat, options)\n\nPerform some sanity checks to ensure that the detected bonds are not obviously wrong because they are either too short or too long.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Crystal-and-CIF-handling","page":"Internals","title":"Crystal and CIF handling","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.remove_partial_occupancy\nCrystalNets.prune_collisions\nCrystalNets.expand_symmetry\nCrystalNets.trim_monovalent\nCrystalNets.trimmed_crystal\nCrystalNets.trim_topology","category":"page"},{"location":"lib/internals/#CrystalNets.remove_partial_occupancy","page":"Internals","title":"CrystalNets.remove_partial_occupancy","text":"remove_partial_occupancy(::CIF)\n\nOnly keep one atom per atom site.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.prune_collisions","page":"Internals","title":"CrystalNets.prune_collisions","text":"prune_collisions(::CIF)\n\nFor each site where there are atoms suspiciously close to one another, remove all but one of them. This arises for example when all the possible positions of at atom are superposed in the CIF file, typically for a solvent which should be disregarded anyway.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.expand_symmetry","page":"Internals","title":"CrystalNets.expand_symmetry","text":"expand_symmetry(::CIF)\n\nApplies all the symmetry operations listed in the CIF file to the atoms and the bonds.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.trim_monovalent","page":"Internals","title":"CrystalNets.trim_monovalent","text":"trim_monovalent(crystal)\n\nRepeatedly remove monovalent atoms from the crystal until none is left.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.trimmed_crystal","page":"Internals","title":"CrystalNets.trimmed_crystal","text":"trimmed_crystal(c::Crystal{Nothing})\n\nRebuild the crystal after trimming its graph according to trim_topology.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.trim_topology","page":"Internals","title":"CrystalNets.trim_topology","text":"trim_topology(graph::PeriodicGraph)\n\nReturn a pair (vmap, newgraph) extracted from the input by removing vertices of valence lower or equal to 1, and by replacing vertices of valence 2 by edges, until convergence. The only exceptions are vertices only bonded to their representatives of another cell: those will not be replaced by edges even if their valence is 2, since this latter case indicates an irreducible trivial 1-dimensional topology.\n\nvmap maps the vertices of newgraph to their counterpart in graph.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Bond-guessing","page":"Internals","title":"Bond guessing","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.guess_bonds\nCrystalNets.edges_from_bonds","category":"page"},{"location":"lib/internals/#CrystalNets.guess_bonds","page":"Internals","title":"CrystalNets.guess_bonds","text":"guess_bonds(pos, types, mat, options)\n\nReturn the bonds guessed from the positions, types and cell matrix, given as a Vector{Vector{Tuple{Int,Float32}}}.\n\nThe i-th entry of the list is a list, whose entries are of the form (j, dist) which indicates that the representatives of vertices i and j distant of at most dist are bonded together.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.edges_from_bonds","page":"Internals","title":"CrystalNets.edges_from_bonds","text":"edges_from_bonds(bonds::Vector{Vector{Tuple{Int,Float32}}}, mat, pos)\n\nGiven a bond list bonds containing triplets (a, b, dist) where atoms a and b are bonded if their distance is lower than dist, the 3×3 matrix of the cell mat and the Vector{SVector{3,Float64}} pos whose elements are the fractional positions of the atoms, extract the list of PeriodicEdge3D corresponding to the bonds. Since the adjacency matrix wraps bonds across the boundaries of the cell, the edges are extracted so that the closest representatives are chosen to form bonds.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Clustering-algorithm","page":"Internals","title":"Clustering algorithm","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.find_sbus!\nCrystalNets.regroup_sbus\nCrystalNets.regroup_paddlewheel!\nCrystalNets.split_sbu!\nCrystalNets.reclassify!\nCrystalNets.add_to_newclass!\nCrystalNets.group_cycle\nCrystalNets.collapse_clusters\nCrystalNets.pem_to_pe\nCrystalNets.allnodes_to_singlenodes","category":"page"},{"location":"lib/internals/#CrystalNets.find_sbus!","page":"Internals","title":"CrystalNets.find_sbus!","text":"find_sbus!(crystal::Crystal, kinds::ClusterKinds=default_sbus)\n\nRecognize SBUs using heuristics based on the atom types corresponding to the AllNodes clustering algorithm.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.regroup_sbus","page":"Internals","title":"CrystalNets.regroup_sbus","text":"regroup_sbus(graph::PeriodicGraph3D, classes::AbstractVector{<:Integer},\n             isolate=Int[])\n\nGiven a classification of vertices into classes, separate the vertices into clusters of contiguous vertices belonging to the same class.\n\nisolate is a list where each atom is separated from the rest of its class. Once all such atoms of its class are isolated, we look for the connected components of non-isolated atoms in that class. If such a component has only one neighbours which is an isolated atom, it is added to the vertex of the isolated atom.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.regroup_paddlewheel!","page":"Internals","title":"CrystalNets.regroup_paddlewheel!","text":"regroup_paddlewheel!(graph, clusters::Clusters, types, periodicsbus)\n\nIdentify paddle-wheel patterns made of two opposite SBUs and regroup them into one.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.split_sbu!","page":"Internals","title":"CrystalNets.split_sbu!","text":"split_sbu!(sbus, graph, i_sbu, classes)\n\nSplit SBU number i_sbu into new SBUs according to the updated classes. The first argument sbus is modified in-place. Return the list of newly-created periodic SBUs, if any.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.reclassify!","page":"Internals","title":"CrystalNets.reclassify!","text":"reclassify!(sbus, newperiodicsbus, newclass, graph, types, classof, i_sbu)\n\nReclassify the atoms of sbus.sbus[i_sbu]) according to the following algorithm:\n\nLet's call \"target atom\" any atom of type typ where classof[typ] == deg and either deg == 0 or deg > 0 and the degree of the atom is deg.\nAssign a new SBU for each target atom (one new per atom).\nLook at the connected components of atoms in the SBU which are not target atoms. For each connected component that is finite (0-dimensional) and has only one neighbor which is a target atom, put that component in the same SBU as the neighbor.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.add_to_newclass!","page":"Internals","title":"CrystalNets.add_to_newclass!","text":"add_to_newclass!(classes, graph, sbus, new_class, v, types, noneighborof)\n\nSet the class of v to new_class. Then, grow the newly created class by adding connected components of the SBU of v such that the new class does not become periodic and does not contain any vertex that is a neighbor of a vertex whose type is in noneighborof.\n\nIf types === nothing, disregard the condition on noneighborof.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.group_cycle","page":"Internals","title":"CrystalNets.group_cycle","text":"group_cycle(organiccycle, types, graph)\n\nReturn a list of Vector{PeriodicVertex3D} where each sublist consists in atoms belonging to the same cycle, and which should thus belong to the same vertex eventually.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.collapse_clusters","page":"Internals","title":"CrystalNets.collapse_clusters","text":"collapse_clusters(crystal::Crystal)\n\nReturn the list of crystals corresponding to the input where each cluster has been transformed into a new vertex, for each targeted clustering.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.pem_to_pe","page":"Internals","title":"CrystalNets.pem_to_pe","text":"pem_to_pe(cryst::Crystal{Nothing})\n\nConvert PEM result to PE by removing all metallic sbus.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.allnodes_to_singlenodes","page":"Internals","title":"CrystalNets.allnodes_to_singlenodes","text":"allnodes_to_singlenodes(cryst::Crystal)\n\nConvert AllNodes result to SingleNodes by collapsing all points of extension clusters bonded together into a new organic cluster.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Unstable-nets","page":"Internals","title":"Unstable nets","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.collision_nodes\nCrystalNets.CollisionNode","category":"page"},{"location":"lib/internals/#CrystalNets.collision_nodes","page":"Internals","title":"CrystalNets.collision_nodes","text":"collision_nodes(c::CrystalNet)\n\nCheck whether the net is stable, i.e. that no two vertices have the same equilibrium placement.\n\nReturn (shrunk_net, (equiv_net, collisions)) where:\n\nequiv_net is a net equivalent to the initial one, with its vertices rotated so that colliding ones are contiguous, and after non-colliding ones.\ncollisions is a list of ranges corresponding to the indices of the vertices that collide to the same node in equiv_net. For example, collisions == [4:5, 6:9] indicates that the vertices 4 and 5 collide to a node, and the vertices 6 to 9 collide to another node. By definition of equiv_net, these ranges are always contiguous and the last range ends with the last vertex of the net. collisions is empty iff the net is stable.\nshrunk_net is the net where all the vertices that collide to a single node are collapsed into a single new vertex. For example, if collisions = [4:5, 6:9], the shrunk_net will only have 5 vertices: vertices 1, 2 and 3 correspond vertices 1, 2 and 3 of the initial net, vertex 4 corresponds to the colliding vertices 4 and 5 of the initial net, and vertex 5 corresponds to the colliding vertices 6 to 9 of the initial net.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Archives","page":"Internals","title":"Archives","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.make_archive","category":"page"},{"location":"lib/internals/#CrystalNets.make_archive","page":"Internals","title":"CrystalNets.make_archive","text":"make_archive(path, destination=nothing, verbose=false)\n\nMake an archive from the files located in the directory given by path and export it to destination, if specified. Each file of the directory should correspond to a unique topology: if a topology is encountered multiple times, it will be assigned the name of the latest file that bore it.\n\nThe archive can then be used with change_current_archive!(destination; validate=false) for instance.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Utils","page":"Internals","title":"Utils","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.@toggleassert\nCrystalNets.check_dimensionality","category":"page"},{"location":"lib/internals/#CrystalNets.@toggleassert","page":"Internals","title":"CrystalNets.@toggleassert","text":"@toggleassert expression\n\nInternal macro used to assert and expression conditionally on a build-time constant. To toggle on or off these assertions, the constant has to be modified in the source code and the module rebuilt afterwards.\n\n\n\n\n\n","category":"macro"},{"location":"lib/internals/#CrystalNets.check_dimensionality","page":"Internals","title":"CrystalNets.check_dimensionality","text":"check_dimensionality(c::CrystalNet)\n\nCheck that the dimensionality of the net (i.e. the number of independent axes along which it is periodic) is equal to D, or throw a DimensionMismatch otherwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Other","page":"Internals","title":"Other","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CrystalNets.guess_topology\nCrystalNets.guess_topology_dataset\nCrystalNets.recognize_topology\nCrystalNets.total_interpenetration","category":"page"},{"location":"lib/internals/#CrystalNets.guess_topology","page":"Internals","title":"CrystalNets.guess_topology","text":"guess_topology(path, options::Options)\nguess_topology(path; kwargs...)\n\nTries to determine the topology of the file at path by passing various options (starting from the provided options if any) until finding a known topology. If none is found, return the topological genome encountered most often through the variation of options.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.guess_topology_dataset","page":"Internals","title":"CrystalNets.guess_topology_dataset","text":"guess_topology_dataset(path, save, autoclean, showprogress, options::Options)\nguess_topology_dataset(path; save=true, autoclean=true, showprogress=true, kwargs...)\n\nGiven a path to a directory containing structure input files, guess the topology of each structure within the directory using guess_topology. Return a dictionary linking each file name to the result. The result is the corresponding topology name, if known, or the topological genome preceded by an \"UNKNOWN\" mention otherwise. In case of error, the result is the exception preceded by a \"FAILED with\" mention. Finally, if the input does not represent a periodic structure, the result is \"0-dimensional\".\n\nIt is strongly recommended to toggle warnings off (through toggle_warning) and not to export any file since those actions may critically reduce performance, especially for numerous files.\n\nThe save and autoclean arguments work identically to their counterpart for determine_topology_dataset.\n\nIf showprogress is set, a progress bar will be displayed representing the number of processed files.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.recognize_topology","page":"Internals","title":"CrystalNets.recognize_topology","text":"recognize_topology(g::PeriodicGraph, arc=CRYSTALNETS_ARCHIVE)\nrecognize_topology(genome::AbstractString, arc=CRYSTALNETS_ARCHIVE)\n\nAttempt to recognize a topological genome from an archive of known genomes.\n\nwarning: Warning\nThis function does a simple lookup, not any kind of topology computation. To identify the topology of a PeriodicGraph or a CrystalNet x, query topological_genome(x) instead.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#CrystalNets.total_interpenetration","page":"Internals","title":"CrystalNets.total_interpenetration","text":"total_interpenetration(itr::InterpenetratedTopologyResult, clustering::Union{Nothing,_Clustering}=nothing)\n\nReturn a Dict{TopologicalGenome,Int} that links each topology to the number of interpenetrated nets having that topology (catenation included) for the given clustering. If clustering is nothing, all possible topologies will be studied.\n\nExample\n\nSee InterpenetratedTopologyResult for reference on these examples.\n\njulia> g = PeriodicGraph(\"2   1 1  0 2   2 2  0 1   2 2  1 0\");\n\njulia> topologies1 = topological_genome(g)\n2 interpenetrated substructures:\n⋅ Subnet 1 → (2-fold) UNKNOWN 1 1 1 1\n⋅ Subnet 2 → sql\n\njulia> CrystalNets.total_interpenetration(topologies1)\nDict{TopologicalGenome, Int64} with 2 entries:\n  UNKNOWN 1 1 1 1 => 2\n  sql             => 1\n\njulia> mof14 = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"MOFs\", \"MOF-14.cif\");\n\njulia> topologies2 = determine_topology(mof14, structure=StructureType.MOF, clusterings=[Clustering.Auto, Clustering.Standard, Clustering.PE])\n2 interpenetrated substructures:\n⋅ Subnet 1 → AllNodes,SingleNodes,Standard: pto | PE: sqc11259\n⋅ Subnet 2 → AllNodes,SingleNodes,Standard: pto | PE: sqc11259\n\njulia> CrystalNets.total_interpenetration(topologies2, Clustering.AllNodes)\nDict{TopologicalGenome, Int64} with 1 entry:\n  pto => 2\n\njulia> CrystalNets.total_interpenetration(topologies2)\nDict{TopologicalGenome, Int64} with 2 entries:\n  pto      => 2\n  sqc11259 => 2\n\n\n\n\n\n","category":"function"},{"location":"mapping/#mapping","page":"Mapping of vertices","title":"Mapping of vertices","text":"","category":"section"},{"location":"mapping/#Principle","page":"Mapping of vertices","title":"Principle","text":"","category":"section"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"CrystalNets.jl extracts the net underlying the input structure, and can identify its name when it exists. Sometimes, it is useful to retrieve the mapping between the input structure and the vertices of the net. This is possible with CrystalNets.jl, using the track_mapping option (see full list of Options)","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"There are multiple ways of using it. One consists in preparing an empty list and passing it to the track_mapping option. The list will contain the mapping at the end of the computation.","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"In the case of a call to determine_topology, the net can be extracted from the InterpenetratedTopologyResult returned by the function, while the number of the input atoms is that corresponding to the \"name\" field of the .vtf file exported with the export_input option. For example:","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"DocTestSetup = quote\n    using CrystalNets\n    import CrystalNets: Options, Clustering, Bonding, StructureType\n    const PeriodicGraphs = CrystalNets.PeriodicGraphs\n    using .PeriodicGraphs\n    using PeriodicGraphs.Graphs\n\n    CrystalNets.toggle_export(false)\n    CrystalNets.toggle_warning(false)\nend","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"julia> path_to_PIVCIJ = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"PIVCIJ.cif\");\n\njulia> mapping = Int[]; # pass an empty list to track_mapping\n\njulia> topology = determine_topology(path_to_PIVCIJ; structure=StructureType.MOF, clusterings=[Clustering.SingleNodes], track_mapping=mapping, export_input=true)\nExport of input is enabled: saving file at /tmp/input_PIVCIJ.vtf\nSingleNodes: fsc\n\njulia> fsc = last(only(first(only(topology))))\nfsc\n\njulia> fsc_graph = PeriodicGraph(fsc)\nPeriodicGraph3D(2, PeriodicEdge3D[(1, 1, (0,0,1)), (1, 2, (-1,0,0)), (1, 2, (-1,1,0)), (1, 2, (0,0,0)), (1, 2, (0,1,0))])\n\njulia> degree(fsc_graph) # fsc has two vertices, of degree respectively 6 and 4\n2-element Vector{Int64}:\n 6\n 4\n\njulia> first(Iterators.drop(eachline(\"/tmp/input_PIVCIJ.vtf\"), 4))\n\"atom 0 type Co name 1 resid 0 atomicnumber 27\"\n\njulia> mapping[1] # atom 1, Co, is mapped to the 6-coordinated vertex\n1\n\njulia> first(Iterators.drop(eachline(\"/tmp/input_PIVCIJ.vtf\"), 11))\n\"atom 7 type C name 8 resid 0 atomicnumber 6\"\n\njulia> mapping[8] # atom 8, C, is part of the 4-coordinated ligand\n2\n\njulia> first(Iterators.drop(eachline(\"/tmp/input_PIVCIJ.vtf\"), 13))\n\"atom 9 type H name 10 resid 0 atomicnumber 1\"\n\njulia> mapping[10] # atom 10, H, has been removed early and has no mapping\n0","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"rm(\"/tmp/input_PIVCIJ.vtf\");","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"note: Note\nThe operation that goes from the InterpenetratedTopologyResult, returned by determine_topology, to the actual genome stored as a PeriodicGraph, is explained in a dedicated FAQ question","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"When using the lower-level topological_genome function, the call will include an Options, either given explicitly (for PeriodicGraph input) or within the passed object if it is a CrystalNet or an UnderlyingNets. In such cases, the mapping can be fetched from the track_mapping field of the given Options after the computation, as long as it was initialized with either an empty list, like in the previous example, or simply the boolean true. For example :","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"julia> crystal_PIVCIJ = parse_chemfile(path_to_PIVCIJ; clusterings=[Clustering.SingleNodes], track_mapping=true);\n\njulia> topological_genome(CrystalNet(crystal_PIVCIJ))\nfsc\n\njulia> crystal_PIVCIJ.options.track_mapping == mapping\ntrue","category":"page"},{"location":"mapping/#Restriction","page":"Mapping of vertices","title":"Restriction","text":"","category":"section"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"warning: Warning\nIn order to have a one-to-one correspondence between the input structure and the net, there must be exactly one net that corresponds to the input. Using track_mapping will thus fail when there is only one track_mapping field for either multiple interpenetrated substructures, or multiple clusterings.","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"For example, the following command errors:","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"julia> determine_topology(path_to_PIVCIJ; structure=StructureType.MOF, track_mapping=mapping)\nERROR: ArgumentError: Cannot keep a single mapping track for multiple sub-nets. Please use keep_single_track=true only on single components with a single clustering.\n[...]","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"The reason is that the structure=StructureType.MOF argument makes the default Clustering.Auto value equivalent to both Clustering.SingleNodes and Clustering.AllNodes, so the previous call is actually evaluating two different clusterings, hence the error.","category":"page"},{"location":"mapping/#Workaround:-the-keep_single_trackfalse-option","page":"Mapping of vertices","title":"Workaround: the keep_single_track=false option","text":"","category":"section"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"A quick workaround consists in adding the keep_single_track=false option. The result of the mapping will then be printed after the computation, but it cannot be retrieved computationally:","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"julia> mapping2 = Int[];\n\njulia> determine_topology(path_to_PIVCIJ; structure=StructureType.MOF, track_mapping=mapping2, keep_single_track=false)\nMapping for CrystalNets.Clustering._Clustering[CrystalNets.Clustering.AllNodes][1, 1, 1, 1, 1, 0, 0, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 3, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nMapping for CrystalNets.Clustering._Clustering[CrystalNets.Clustering.SingleNodes][1, 1, 1, 1, 1, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nAllNodes: sqc27\nSingleNodes: fsc\n\njulia> mapping2 # untouched, cannot be used to retrieve the mapping\nInt64[]","category":"page"},{"location":"mapping/#Subnet-separation","page":"Mapping of vertices","title":"Subnet separation","text":"","category":"section"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"A more proper solution to this issue consists in creating separate CrystalNet instances, one for each substructure and for each target clustering, and thus with their own separate track_mapping field. The UnderlyingNets constructor can be used for this purpose, starting from a CrystalNets.Crystal. For example:","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"DocTestSetup = quote\n    using CrystalNets\n    import CrystalNets: Options, Clustering, Bonding, StructureType\n    const PeriodicGraphs = CrystalNets.PeriodicGraphs\n    using .PeriodicGraphs\n    using PeriodicGraphs.Graphs\n\n    CrystalNets.toggle_export(false)\n    CrystalNets.toggle_warning(false)\nend","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"julia> path_to_WEBZEK = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"MOFs\", \"WEBZEK.cif\");\n\njulia> crystal_webzek = parse_chemfile(path_to_WEBZEK; structure=StructureType.MOF);\n\njulia> unets_webzek = UnderlyingNets(crystal_webzek);\n\njulia> topological_genome(unets_webzek) # there are 2 interpenetrated subnets, with 2 clusterings each\n2 interpenetrated substructures:\n⋅ Subnet 1 → AllNodes,SingleNodes: bcu\n⋅ Subnet 2 → AllNodes,SingleNodes: dia\n\njulia> webzekA, webzekB = first.(unets_webzek.D3) # only keep 3D nets here\n2-element Vector{Vector{CrystalNet3D}}:\n [CrystalNet3D{Rational{Int32}} of WEBZEK_1 with 8 vertices and 32 edges (clustering: AllNodes), CrystalNet3D{Rational{Int32}} of WEBZEK_1 with 8 vertices and 32 edges (clustering: SingleNodes)]\n [CrystalNet3D{Rational{Int32}} of WEBZEK_2 with 4 vertices and 8 edges (clustering: AllNodes), CrystalNet3D{Rational{Int32}} of WEBZEK_2 with 4 vertices and 8 edges (clustering: SingleNodes)]","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"Say we focus on a particular net, for instance the AllNodes clustering of substructure B. After selecting it, its Options can be modified by wrapping it in the CrystalNet constructor and using the appropriate keyword arguments:","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"julia> subnet = webzekB[1]\nCrystalNet3D{Rational{Int32}} of WEBZEK_2 with 4 vertices and 8 edges (clustering: AllNodes)\n\njulia> newmapping = Int[];\n\njulia> newsubnet = CrystalNet(subnet; track_mapping=newmapping);\n\njulia> topological_genome(newsubnet)\ndia\n\njulia> newmapping\n4-element Vector{Int64}:\n 1\n 2\n 2\n 1","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"Note that the call CrystalNet(subnet; track_mapping=newmapping) does not modify subnet: it simply creates a copy of subnet with a modified track_mapping field. As a consequence, subnet.options.track_mapping cannot be used to track the result of the computation of topological_genome(newsubnet):","category":"page"},{"location":"mapping/","page":"Mapping of vertices","title":"Mapping of vertices","text":"julia> newmapping === newsubnet.options.track_mapping != subnet.options.track_mapping\ntrue","category":"page"},{"location":"python/#Python-interface","page":"Python","title":"Python interface","text":"","category":"section"},{"location":"python/#Setup","page":"Python","title":"Setup","text":"","category":"section"},{"location":"python/","page":"Python","title":"Python","text":"It is possible to call Julia code from Python using the dedicated package juliacall. This page is a simple tutorial detailing how to set it up and use it for CrystalNets.","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"In the folder where you intend to put your python script, add a new file called juliapkg.json with the following content:","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"{\n    \"julia\": \"1\",\n    \"packages\": {\n        \"CrystalNets\": {\n            \"uuid\": \"7952bbbe-a946-4118-bea0-081a0932faa9\",\n            \"version\": \"1.0\"\n        }\n    }\n}","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"then install juliacall with pip install juliacall. From there, you can call CrystalNets by starting your python script with the following three lines:","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"import juliacall\njl = juliacall.newmodule(\"TheNameOfYourModule\") # put whatever name here\njl.seval(\"using CrystalNets\")","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"note: Note\nThe very first time these three lines are run in your system, julia will install CrystalNets and its dependencies. This can take a while, but it will only occur once.","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"Afterwards, you can call any function of CrystalNets.jl (and Julia in general) by prefixing them with jl., for instance:","category":"page"},{"location":"python/","page":"Python","title":"Python","text":">>> jl.determine_topology(\"/path/to/MIL-53.cif\")\n[ Error: Atom ?, used in a bond, has either zero or multiple placements in the CIF file. This invalidates all bonds from the file, which will thus be discarded.\n[ Warning: Guessing bonds with custom algorithm (from Chemfiles and VMD). This may take a while for big structures and may be inexact.\n[ Info: To avoid guessing bonds, use a file format that contains the bonds.\nExport of input is enabled: saving file at /tmp/input_MIL-53.vtf\nExport of subnet_Auto is enabled: saving file at /tmp/subnet_Auto_MIL-53.vtf\nJulia: rna","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"Compare this to the equivalent REPL execution in Julia:","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"julia> using CrystalNets\n\njulia> determine_topology(\"/path/to/MIL-53.cif\")\n[ Error: Atom ?, used in a bond, has either zero or multiple placements in the CIF file. This invalidates all bonds from the file, which will thus be discarded.\n[ Warning: Guessing bonds with custom algorithm (from Chemfiles and VMD). This may take a while for big structures and may be inexact.\n[ Info: To avoid guessing bonds, use a file format that contains the bonds.\nExport of input is enabled: saving file at /tmp/input_MIL-53.vtf\nExport of subnet_Auto is enabled: saving file at /tmp/subnet_Auto_MIL-53.vtf\nrna","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"The same warnings are printed at the beginning, followed by the same exports. The only difference is that the result, rna (the topology of MIL-53), is prefixed by Julia: in the Python output.","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"tip: Tip\nYou can disable the warnings and/or the exports by adding the following lines after the three initial lines above:jl.CrystalNets.toggle_warning(False) # to disable warnings\njl.CrystalNets.toggle_export(False) # to disable exports","category":"page"},{"location":"python/#Usage","page":"Python","title":"Usage","text":"","category":"section"},{"location":"python/","page":"Python","title":"Python","text":"Let's now consider a programmatic use-case where the goal is to identify the topology of a complex MOF structure according the SingleNodes and AllNodes clusterings. The main structure may contain interpenetrating substructures.","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"The function is expected to error if the topologies are different between the two clusterings. Otherwise, it returns a list of pairs whose first element is the dimensionality of the subnet and the second element is the name of the corresponding topology. If there is no known name, the topological genome is used instead.","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"The Python code is the following:","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"def identify_topology(cif):\n    \"\"\"Return a list of pairs (dimensionality, topology) for each substructure of the file\"\"\"\n    options = jl.CrystalNets.Options(structure=jl.StructureType.MOF)\n    # Since the structure is specified as a MOF, the default clusterings are AllNodes and SingleNodes\n    result = jl.determine_topology(cif, options) # Main call\n    # for each x in result:\n    # * x[0] is the topology of the substructure.\n    # * x[1] is the catenation multiplicity of this subnet.\n    return [check_unique_topology(x[0]) for x in result]\n\ndef check_unique_topology(result):\n    singlenodes = result[jl.Clustering.SingleNodes] # topology for SingleNodes\n    allnodes = result[jl.Clustering.AllNodes] # topology for AllNodes\n    if singlenodes != allnodes:\n        raise Exception(\"SingleNodes result \"+str(singlenodes)+\" != AllNodes result \"+str(allnodes))\n    return (jl.ndims(singlenodes.genome), str(singlenodes))","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"Let's try this on a few examples:","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"HKUST-1 has a 3-dimensional topology tbo:\n>>> identify_topology(\"/path/to/HKUST-1.cif\")\n[(3, 'tbo')]\nODIZIK is composed of two intepenetrating 2-dimensional topologies sql\n>>> identify_topology(\"/path/to/ODIZIK.cif\")\n[(2, 'sql'), (2, 'sql')]\nMIL-53 is has topology bpq with SingleNodes clustering and rna with AllNodes so the function errors:\n>>> identify_topology(\"/path/to/MIL-53.cif\")\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 11, in identify_topology\nFile \"<stdin>\", line 5, in check_unique_topology\nException: SingleNodes result bpq != AllNodes result rna","category":"page"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"When processing individual files through CrystalNets.jl, it is often useful to check whether the detected net actually corresponds to the expected one. To allow this, both the parsed input file as well as the detected subnets are automatically exported by default as VTF files. This file format is recognized by the molecular visualization program VMD and has the property of including explicit bonds, which is necessary in order to represent nets in an unambiguous way.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This mini-tutorial shows a setup to conveniently use VMD to check the adequate superposition of the crystal and its underlying net. It is not a VMD tutorial itself: to find more resources, check the official website.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"tip: Tip\nTo toggle off the automatic export of VTF files, use CrystalNets.toggle_export. The automatic export setting is bypassed when giving explicity values to export_* keyword arguments through CrystalNets.Options or directly to the determine_topology function (and other related functions).","category":"page"},{"location":"visualization/#VMD-setup","page":"Visualization","title":"VMD setup","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"After downloading and installing VMD, it can be convenient to customize your setup to taylor your needs. In addition to the official VMD website, an excellent resource for this is Axel Kohlmeyer's personal website.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The following code, heavily inspired from that website, can be appended to your .vmdrc or vmd.rc file to automatically show VTF files using CPK representations, with big spheres and bonds for nets and small ones for the input crystal:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"package require pbctools\n\ndisplay projection orthographic  # orthographic makes it easier to see the symmetries\n\nproc reset_viz {molid} {\n  # operate only on existing molecules\n  if {[lsearch [molinfo list] $molid] >= 0} {\n    # delete all representations\n    set numrep [molinfo $molid get numreps]\n    for {set i 0} {$i < $numrep} {incr i} {\n      mol delrep $i $molid\n    }\n    # add new representations\n    mol color Element  # color each atom according to its element\n    set name [molinfo $molid get name]\n    if {[regexp {.*net.*\\.vtf} $name] || [regexp {.*clusters.*\\.vtf} $name]} {\n        mol representation CPK 1.2 0.6  # for nets: big spheres\n    } elseif {[regexp {.*\\.vtf} $name]} {\n        mol representation CPK 0.6 0.2  # for input: small spheres\n    }\n    mol selection all\n    mol addrep $molid\n    pbc box  # add the unit cell\n  }\n}\n\nproc reset_viz_proxy {args} {\n  foreach {fname molid rw} $args {}\n  eval \"after idle {reset_viz $molid}\"\n}\n\ntrace variable vmd_initialize_structure w reset_viz_proxy\n\n#color Element C black  # uncomment to have carbon atoms in black\n\nafter idle { reset_viz 0 }","category":"page"},{"location":"visualization/#An-example","page":"Visualization","title":"An example","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"DocTestSetup = quote\n    using CrystalNets\n    CrystalNets.toggle_warning(true)\n    CrystalNets.toggle_export(true)\nend\nDocTestFilters = r\"saving file at .*\\_IM\\-19\\_[0-9]+\\.vtf\"","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Let's consider IM-19 as an example of crystalline framework we are studying. A CIF file for this structure (available from Chaplais et. al. on the CSD) can be accessed at:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> path_to_im19 = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"IM-19.cif\");","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Determining its topology yields the following:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> determine_topology(path_to_im19; bonding=Bonding.Guess, structure=StructureType.MOF)\n[ Info: Initial pass found O and C with invalid number of bonds.\nExport of input is enabled: saving file at /tmp/input_IM-19.vtf\nExport of subnet_AllNodes is enabled: saving file at /tmp/subnet_AllNodes_IM-19_1.vtf\nExport of subnet_SingleNodes is enabled: saving file at /tmp/subnet_SingleNodes_IM-19_1.vtf\nAllNodes: rna\nSingleNodes: bpq","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"rm(\"/tmp/input_IM-19.vtf\");\nrm(\"/tmp/subnet_AllNodes_IM-19_1.vtf\");\nrm(\"/tmp/subnet_SingleNodes_IM-19_1.vtf\");","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"DocTestSetup = nothing\nDocTestSetup = begin\n    using CrystalNets\n    import CrystalNets: Options, Clustering, Bonding, StructureType\n    const PeriodicGraphs = CrystalNets.PeriodicGraphs\n    using .PeriodicGraphs\n\n    CrystalNets.toggle_export(false)\n    CrystalNets.toggle_warning(false)\nend\nDocTestFilters = nothing","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Although not necessary, we manually specified bonding=Bonding.Guess to avoid the following warning","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"[ Warning: Guessing bonds with custom algorithm (from Chemfiles and VMD). This may take a while for big structures and may be inexact.\n[ Info: To avoid guessing bonds, use a file format that contains the bonds.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The first line of the output is an information about atoms with initial number of bonds. Note that there is no subsequent warning of the form","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"[ Warning: After attempted fix, found remaining C with invalid number of bonds.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"which indicates that the problem has been internally resolved. It might be good to manually check whether the guessed bonds make sense, as an extra precaution.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To do so, simply open VMD and load the VTF file corresponding to the input. On Ubuntu, the following shell command can be used:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"vmd /tmp/input_IM-19_0.vtf","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The result will look like this: (Image: IM-19 visualization in VMD)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To visualize the \"single nodes\" clusters on top of the input, navigate to File -> New Molecule... in the VMD window and load the adequate VTF file (in our case, the one located at /tmp/subnet_SingleNodes_IM-19_0.vtf). The result should look like this: (Image: IM-19 with single nodes clusters superposed)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To look at the underlying topology only (in our case, the bpq net), you can toggle off the visualization of the input file by double-clicking on the D letter left to the input file name in the main VMD window. The result should look like this: (Image: bpq net underlying IM-19)","category":"page"},{"location":"visualization/#exports","page":"Visualization","title":"Export options","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"There are several export options bundled with CrystalNets.jl, documented in the Options. Each of them can be given as keyword arguments to all functions accepting an Options argument, like determine_topology.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The value of the keyword argument can be either:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"a String representing the path of the directory in which to put the exported file. If empty, this disables the export.\na Bool: if true, equivalent to tempdir(); if false, disables the export.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The two exports whose default value is defined by CrystalNets.toggle_export are:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"export_input for the parsed structure.\nexport_subnets for each subnet, defined after clustering and separated into connected components.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Other available export options are disabled by default:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"export_trimmed for the trimmed parsed structure. \"Trimming\" refers to removing all atoms that have strictly less than three neighbours and bonding those neighbours together, and so iteratively until no atom remains with strictly less than three neighbours.\nThis export can be useful for debugging since the clustering algorithm runs on the trimmed input, or to remove simple solvent molecules.\nexport_attributions for the classes of the atoms, as defined by the clustering algorithm. This is exported as a PDB file, which can also be natively read by VMD: to see the attributions, switch to \"Type\" for the coloring method instead of \"Element\".\nexport_clusters for the clusters. The only difference with export_subnets is that the graph induced by the clusters is not trimmed yet.\nexport_net for the net before separation into connected components. This is equivalent to concatenating the result of export_subnets into a single file.","category":"page"},{"location":"#CrystalNets.jl","page":"Home","title":"CrystalNets.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CrystalNets.jl is a Julia package for automatic detection and identification of net topologies underlying crystalline materials. Its inputs can be chemical files in any format recognized by chemfiles.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use it directly without any installation, simply use the website interface: https://progs.coudert.name/topology","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use it through Python, check the Python interface tutorial.","category":"page"},{"location":"#Package-installation","page":"Home","title":"Package installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The installation follows the usual procedure. Start by downloading and installing Julia, v1.10 or more recent. Then, either","category":"page"},{"location":"","page":"Home","title":"Home","text":"open the Julia REPL and enter the package manager by typing ], then install CrystalNets.jl by entering:\npkg> add CrystalNets\nalternatively, you can do it from a shell by executing:\njulia -e 'import Pkg; Pkg.add(\"CrystalNets\")'","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, open a REPL and enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using CrystalNets","category":"page"},{"location":"#Quick-usage-as-a-module","page":"Home","title":"Quick usage as a module","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To determine the topology of a structure stored in a file at location path, simply call","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> determine_topology(path)","category":"page"},{"location":"#Known-nets","page":"Home","title":"Known nets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If recognized, this yields the name of the net. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> determine_topology(\"/path/to/diamond.cif\")\nExport of input is enabled: saving file at /tmp/input_diamond_0.vtf\nExport of subnet_Auto is enabled: saving file at /tmp/subnet_Auto_diamond_0.vtf\ndia","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, the parsed input and the extracted underlying nets are exported as .vtf files (see Visualization). To toggle on or off automatic exports, use CrystalNets.toggle_export, and similarly with CrystalNets.toggle_warning for warnings.","category":"page"},{"location":"#Unnamed-nets","page":"Home","title":"Unnamed nets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the net is not recognized as part of either the RCSR, EPINET or as a known zeolite, its topological genome is displayed preceded by an \"UNKNOWN\" mention:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> determine_topology(\"/path/to/new/material.cif\")\nUNKNOWN 2 1 2 -2 0 1 2 0 0 1 2 0 1 2 2 1 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"In both known and unknown cases, the result is an InterpenetratedTopologyResult.","category":"page"},{"location":"#Interpenetrating-substructures","page":"Home","title":"Interpenetrating substructures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the file contains multiple interpenetrating substructures, each substructure and its catenation multiplicity can be extracted from the InterpenetratedTopologyResult.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> x = determine_topology(\"/path/to/intertwinned/structures.cif\")\n2 interpenetrated substructures:\n⋅ Subnet 1 → pcu\n⋅ Subnet 2 → srs","category":"page"},{"location":"#Using-options","page":"Home","title":"Using options","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Options can be added as individual keyword arguments to the call. For instance:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> path_to_mof5 = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"MOF-5.cif\");\n\njulia> determine_topology(path_to_mof5; structure=StructureType.MOF,\n                                        clusterings=[Clustering.PE,Clustering.Standard],\n                                        split_O_vertex=false)\nPE: cab\nStandard: fff","category":"page"},{"location":"#Installation-as-an-executable","page":"Home","title":"Installation as an executable","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To obtain an executable, CrystalNets.jl can be statically compiled. To do so, run the following julia script after changing the INSTALLATION_PATH variable to the location where the CrystalNets.jl executable will be installed. Note that this requires the PackageCompiler module.","category":"page"},{"location":"","page":"Home","title":"Home","text":"const INSTALLATION_PATH = \"/fill/with/installation/path\"\n\nusing PackageCompiler\nusing CrystalNets\n\nconst root = dirname(dirname(pathof(CrystalNets)))\n\ncreate_app(root, INSTALLATION_PATH;\n           precompile_statements_file=abspath(root, \"src\", \"precompile_statements.jl\"),\n           filter_stdlibs=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compilation can take a long time, depending on your hardware and the version of Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The executable will be located in the \"bin\" subdirectory of the specified INSTALLATION_PATH, under the name \"CrystalNets\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"The executable can then simply be used on a chemical file:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ CrystalNets /path/to/diamond.cif\ndia","category":"page"},{"location":"","page":"Home","title":"Home","text":"Run CrystalNets --help for the list of options available to the executable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nFor casual usage, using the website is the most convenient option, unless the nets you study are too big.For intensive workloads with many structures to identify, it is best to use CrystalNets.jl as a Julia module through the determine_topology_dataset function. The module is also the best option to perform more advanced analyses on the net in Julia, or to use the Options unavailable to the executable or the website.","category":"page"},{"location":"faq/#Troubleshooting","page":"FAQ","title":"Troubleshooting","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This page covers a few issues that may occur when using CrystalNets.jl. If your problem is not mentioned here, you can open an issue.","category":"page"},{"location":"faq/#Can-I-use-this-without-programming,-or-if-I-do-not-know-Julia?","page":"FAQ","title":"Can I use this without programming, or if I do not know Julia?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Sure! If you only want to identify the topology of a structure, the easiest way is to use the website interface at https://progs.coudert.name/topology","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you want to use the package in a programmatic way through Python, please check the dedicated Python interface tutorial.","category":"page"},{"location":"faq/#How-can-I-check-that-the-detected-topology-corresponds-to-my-input?","page":"FAQ","title":"How can I check that the detected topology corresponds to my input?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This is the focus of the Visualization tutorial. You may also want to check the Vertex mapping tutorial.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"On the website, a visualization panel automatically opens once the topology is computed, which enables checking the correspondence between the topology and the input.","category":"page"},{"location":"faq/#How-can-I-silence-warnings-or-remove-exports?","page":"FAQ","title":"How can I silence warnings or remove exports?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"From the module: see CrystalNets.toggle_warning, CrystalNets.toggle_error and CrystalNets.toggle_export\nFrom the executable: use the --no-warn, --no-error and --no-export flags.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"For exports, each export_... keyword argument to Options can be individually set to false or \"\" to silence this particular export. See also the paragraph on export options.","category":"page"},{"location":"faq/#How-can-I-choose-a-particular-clustering-algorithm?","page":"FAQ","title":"How can I choose a particular clustering algorithm?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Pass the appropriate option from Clustering to the clusterings keyword argument of Options, or use the -c flag from the executable. For example, to compute the topology of UiO-66 with the Points-of-Extension (PE) clustering algorithm, do","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"DocTestSetup = quote\n    using CrystalNets\n    import CrystalNets: Options, Clustering, Bonding, StructureType\n    const PeriodicGraphs = CrystalNets.PeriodicGraphs\n    using .PeriodicGraphs\n\n    CrystalNets.toggle_export(false)\n    CrystalNets.toggle_warning(false)\nend","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> path_to_uio66 = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"UiO-66.cif\");\n\njulia> determine_topology(path_to_uio66; structure=StructureType.MOF, clusterings=[Clustering.PE])\nPE: ubt","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The clusterings keyword argument accepts a list of Clusterings you can check multiple clusterings at once while factoring useless computations. For example:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> determine_topology(path_to_uio66; structure=StructureType.MOF, clusterings=[Clustering.Standard, Clustering.Auto])\nStandard: xbi\nAllNodes, SingleNodes: fcu","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Note that Auto is equivalent to both AllNodes and SingleNodes when the StructureType is set to MOF.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"See below for the reason why the Standard topology is xbi and not ToposPro's \"3,4,8T15\".","category":"page"},{"location":"faq/#CrystalNets.jl-incorrectly-detects-bonds-or-reports-a-periodic-structure-as-\"0-dimensional\"","page":"FAQ","title":"CrystalNets.jl incorrectly detects bonds or reports a periodic structure as \"0-dimensional\"","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"You can use the Visualization tutorial to identify which bonds are incorrectly detected or missing.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Check that the input file is clean: if an atom is represented in multiple possible positions for instance (as is common in CIF files), CrystalNets.jl could mistake them as multiple atoms, which may break some heuristics of the bond-detection algorithm. Solvent residues may also be incorrectly bonded in some circumstances and should be removed. The ignore_atoms keyword argument in the Options may be useful in this regard.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"You may want to provide a different structure keyword argument in the Options taken among the possible instances of StructureType. These can modify the default heuristics for bond-guessing: for example, using structure=StructureType.MOF gives metals a larger radius for the purpose of guessing bonds.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"There are several customizable heuristics for bond-guessing available among the Options. Of particular interest are cutoff_coeff, ignore_homoatomic_bonds and several of the options in the \"Miscellaneous\" section.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If nothing works, the last solution consists in providing an input file with explicit bonds set, and use the bonding=Bonding.Input keyword argument to Options.","category":"page"},{"location":"faq/#The-topology-has-a-name-given-by-ToposPro-but-CrystalNets.jl-yields-\"UNKNOWN-...\"","page":"FAQ","title":"The topology has a name given by ToposPro but CrystalNets.jl yields \"UNKNOWN ...\"","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In CrystalNets.jl, a net is identified if the graph of the crystal is isomorphic to the net. This correspondence is exact. To do so, CrystalNets.jl actually solves the more complex graph canonicalization problem which consists in finding a \"genome\" (a sequence of numbers) provably unique for each net and such that two isomorphic nets have the same genome. Each genome is then associated with a name. See this article for more information on the implementation in the program Systre, from which CrystalNets.jl is derived.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"ToposPro does not exactly solve the periodic graph isomorphism problem: instead, it identifies the graph of a crystal as a known net if both share a number of properties (coordination sequences up to a certain point, point symbols and vertex symbols, see this article). This is usually an excellent approximation, but it is mathematically unsound as there may exist two non-isormorphic nets sharing these three properties. In particular, this means that there cannot be a unique topological genome defined for these \"nets\" recognized by ToposPro. As a consequence, they cannot be used by CrystalNets.jl.","category":"page"},{"location":"faq/#ToposProStandard","page":"FAQ","title":"Why is the topology computed with Standard different from ToposPro's standard?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"While both algorithms usually align, the result may not be the same in all cases because they are not defined in the same way.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Most often, the difference will come from either:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"an oxygen atom having three (or more) bonds becomes a vertex for ToposPro but is removed by CrystalNets.jl in MOFs. To use ToposPro's default behaviour, set split_O_vertex=false in the Options.\na paddle-wheel pattern is grouped into a single cluster by CrystalNets.jl but not by ToposPro. To use ToposPro's default behaviour, use detect_paddlewheels=false in the Options.","category":"page"},{"location":"faq/#How-can-I-do-a-database-topology-analysis-with-CrystalNets.jl?","page":"FAQ","title":"How can I do a database topology analysis with CrystalNets.jl?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The built-in way to do this consists in using the determine_topology_dataset function. This function expects the path of a directory containing CIF files within (possibly in subdirectories).","category":"page"},{"location":"faq/#genomefromname","page":"FAQ","title":"How can I directly access the genome of my structure instead of its name?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The result x of determine_topology is an InterpenetratedTopologyResult. Its length gives the number of interpenetrated substructures. Each of its values, for instance x[1], is a tuple (topo, n) meaning that the substructure is an n-fold catenated net of topology topo. topo itself is a TopologyResult, which stores the result of a topology computation for possibly several clusterings. The TopologicalGenome associated to a given clustering can be extracted by indexing the TopologyResult, for instance t = topo[Clustering.SingleNodes] (or simply t = topo[:SingleNodes]).","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"For example:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> path_to_im19 = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"IM-19.cif\");\n\njulia> result = determine_topology(path_to_im19; structure=StructureType.MOF)\nAllNodes: rna\nSingleNodes: bpq\n\njulia> typeof(result)\nInterpenetratedTopologyResult\n\njulia> length(result)\n1\n\njulia> topo, n = only(result);\n\njulia> n # catenation multiplicity\n1\n\njulia> topo\nAllNodes: rna\nSingleNodes: bpq\n\njulia> typeof(topo)\nTopologyResult\n\njulia> genome_allnodes = topo[Clustering.AllNodes]\nrna\n\njulia> typeof(genome_allnodes)\nTopologicalGenome","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In case where all clusterings lead to the same genome, it can simply be accessed by calling first(topo).","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Having obtained a TopologicalGenome, the topological genome itself can accessed by converting it to a PeriodicGraph:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> genome = PeriodicGraph(genome_allnodes)\nPeriodicGraph3D(6, PeriodicEdge3D[(1, 2, (0,0,0)), (1, 3, (0,0,0)), (1, 4, (0,0,0)), (1, 4, (0,0,1)), (1, 5, (0,0,0)), (1, 6, (0,0,0)), (2, 4, (0,0,1)), (2, 6, (-1,0,0)), (3, 4, (0,0,1)), (3, 5, (0,-1,0)), (4, 5, (0,0,0)), (4, 6, (0,0,0))])","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In case of error during topology identification, the returned genome is a PeriodicGraph{0}.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The string representation of the genome is simply string(genome):","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> string(genome)\n\"3 1 2 0 0 0 1 3 0 0 0 1 4 0 0 0 1 4 0 0 1 1 5 0 0 0 1 6 0 0 0 2 4 0 0 1 2 6 -1 0 0 3 4 0 0 1 3 5 0 -1 0 4 5 0 0 0 4 6 0 0 0\"","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In case the topology is unique, or unique for the given clustering, you can use the shortcut function one_topology.","category":"page"},{"location":"faq/#Can-I-identify-which-input-atom-maps-to-which-vertex-of-the-returned-genome?","page":"FAQ","title":"Can I identify which input atom maps to which vertex of the returned genome?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Yes, that is the purpose of the track_mapping option, detailed in the Vertex mapping tutorial.","category":"page"},{"location":"lib/public/#API","page":"Public","title":"API","text":"","category":"section"},{"location":"lib/public/#Main-types","page":"Public","title":"Main types","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"CrystalNet\nUnderlyingNets\nTopologicalGenome\nTopologyResult\nInterpenetratedTopologyResult","category":"page"},{"location":"lib/public/#CrystalNets.CrystalNet","page":"Public","title":"CrystalNets.CrystalNet","text":"CrystalNet{D,T<:Real}\n\nRepresentation of a net as a topological abstraction of a crystal.\n\nD is the dimensionality of the net, which is the number of repeated dimensions of a single connex component. This dimensionality is not necessarily the dimension of the space the crystal is embedded into, which would always be 3 for real space.\n\nT is the numeric type used to store the exact coordinates of each vertex at the equilibrium placement.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystalNets.UnderlyingNets","page":"Public","title":"CrystalNets.UnderlyingNets","text":"UnderlyingNets\n\nGrouping of the connected components of a structure according to their dimensionality.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystalNets.TopologicalGenome","page":"Public","title":"CrystalNets.TopologicalGenome","text":"TopologicalGenome\n\nA topological genome computed by CrystalNets.jl.\n\nStore both the actual genome (as a PeriodicGraph) and the name of the net, if recognized.\n\nLike for a PeriodicGraph, the textual representation of a TopologicalGenome can be parsed back into a TopologicalGenome:\n\njulia> topology = topological_genome(CrystalNet(PeriodicGraph(\"2  1 2 0 0  2 1 0 1  2 1 1 0\")))\nhcb\n\njulia> typeof(topology)\nTopologicalGenome\n\njulia> PeriodicGraph(topology)  # The actual topological genome, as a PeriodicGraph\nPeriodicGraph2D(2, PeriodicEdge2D[(1, 2, (-1,0)), (1, 2, (0,0)), (1, 2, (0,1))])\n\njulia> parse(TopologicalGenome, \"hcb\") == topology\ntrue\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystalNets.TopologyResult","page":"Public","title":"CrystalNets.TopologyResult","text":"TopologyResult\n\nThe result of a topology computation on a structure with different Clustering options.\n\nIts representation includes the name of the clustering options along with their corresponding genome. It is omitted if there is only one clustering option which is Auto.\n\nLike for a TopologicalGenome (or a PeriodicGraph), the textual representation of a TopologyResult can be parsed back to a TopologyResult:\n\njulia> mof5 = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"MOF-5.cif\");\n\njulia> topologies = only(determine_topology(mof5, structure=StructureType.MOF, clusterings=[Clustering.Auto, Clustering.Standard, Clustering.PE]))[1]\nAllNodes, SingleNodes: pcu\nStandard: xbh\nPE: cab\n\njulia> typeof(topologies)\nTopologyResult\n\njulia> parse(TopologyResult, repr(topologies)) == topologies\ntrue\n\nSee also TopologicalGenome and InterpenetratedTopologyResult.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystalNets.InterpenetratedTopologyResult","page":"Public","title":"CrystalNets.InterpenetratedTopologyResult","text":"InterpenetratedTopologyResult <: AbstractVector{Tuple{TopologyResult,Int}}\n\nThe result of a topology computation on a structure containing possibly several interpenetrated substructures.\n\nAn InterpenetratedTopologyResult can be seen as a list of (topology, n) pair where\n\ntopology is the TopologyResult corresponding to the substructures.\nn is an integer such that the substructure is composed of an n-fold catenated net.\n\nThe entire structure can thus be decomposed in a series of substructures, each of them possibly decomposed into several catenated nets.\n\ninfo: Vocabulary\nIn this context, interpenetration and catenation have slightly different meanings:two (or more) substructures are interpenetrated if both are present in the unit cell, and are composed of vertices that have disjoint numbers. They may or may not all have the same topology since they are disjoint and independent subgraphs. For example:\njulia> topological_genome(PeriodicGraph(\"2   1 1  0 1   2 2  0 1   2 2  1 0\"))\n2 interpenetrated substructures:\n⋅ Subnet 1 → UNKNOWN 1 1 1 1\n⋅ Subnet 2 → sql\na net is n-fold catenated if the unit cell of a single connected component of the net is n times larger than the unit cell of the overall net. In that case, the net is actually made of n interpenetrating connected components, which all have the same topology. For example:\njulia> topological_genome(PeriodicGraph(\"3   1 1  2 0 0   1 1  0 1 0   1 1  0 0 1\"))\n(2-fold) pcuBoth may occur inside a single structure, for example:julia> topological_genome(PeriodicGraph(\"2   1 1  0 2   2 2  0 1   2 2  1 0\"))\n2 interpenetrated substructures:\n⋅ Subnet 1 → (2-fold) UNKNOWN 1 1 1 1\n⋅ Subnet 2 → sqlNote that catenation is a particular case of interpenetration: an n-fold catenated net repeated into a supercell n times larger becomes n interpenetrated nets.tip: Tip\nSee also total_interpenetration to abstract away the difference between interpenetration and catenation.\n\nExample\n\njulia> mof14 = joinpath(dirname(dirname(pathof(CrystalNets))), \"test\", \"cif\", \"MOFs\", \"MOF-14.cif\");\n\njulia> topologies = determine_topology(mof14, structure=StructureType.MOF, clusterings=[Clustering.Auto, Clustering.Standard, Clustering.PE])\n2 interpenetrated substructures:\n⋅ Subnet 1 → AllNodes,SingleNodes,Standard: pto | PE: sqc11259\n⋅ Subnet 2 → AllNodes,SingleNodes,Standard: pto | PE: sqc11259\n\njulia> typeof(topologies)\nInterpenetratedTopologyResult\n\njulia> parse(InterpenetratedTopologyResult, repr(topologies)) == topologies\ntrue\n\njulia> topologies[2]\n(AllNodes, SingleNodes, Standard: pto\nPE: sqc11259, 1)\n\njulia> topology, n = topologies[2]; # second subnet\n\njulia> n # catenation multiplicity\n1\n\njulia> topology\nAllNodes, SingleNodes, Standard: pto\nPE: sqc11259\n\njulia> typeof(topology)\nTopologyResult\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Main-functions","page":"Public","title":"Main functions","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"determine_topology\ndetermine_topology_dataset\nparse_chemfile\ntopological_genome","category":"page"},{"location":"lib/public/#CrystalNets.determine_topology","page":"Public","title":"CrystalNets.determine_topology","text":"determine_topology(path, options::Options)\ndetermine_topology(path; kwargs...)\n\nCompute the topology of the structure described in the file located at path. This is exactly equivalent to calling topological_genome(UnderlyingNets(parse_chemfile(path, options))).\n\nReturn an InterpenetratedTopologyResult.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.determine_topology_dataset","page":"Public","title":"CrystalNets.determine_topology_dataset","text":"determine_topology_dataset(path, save, autoclean, showprogress, options::Options)\ndetermine_topology_dataset(path; save=true, autoclean=true, showprogress=true, kwargs...)\n\nGiven a path to a directory containing structure input files, compute the topology of each structure within the directory. Return a dictionary linking each file name to the result. The result is a InterpenetratedTopologyResult, containing the topological genome, the name if known and the stability of the net. In case of error, the exception is reported.\n\nWarnings will be toggled off (unless force_warn is set) and it is stongly recommended not to export any file since those actions may critically reduce performance, especially for numerous files.\n\nIf save is set, the result is also stored in a julia serialized file located at \"$path/../results_$i\" where i is the lowest integer such that this path does not already exist at the start of the computation. While processing, this path will be used to create a directory storing the current state of the computation: to continue an interrupted computation, simply pass this temporary directory as the path. If autoclean is set, this directory is removed at the end if the computation was successful.\n\nIf save is set and autoclean is unset, the directory of temporary files will be renamed into \"$path/../results_$i.OLD$j\".\n\nIf showprogress is set, a progress bar will be displayed representing the number of processed files.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.parse_chemfile","page":"Public","title":"CrystalNets.parse_chemfile","text":"   parse_chemfile(path, options::Options)\n   parse_chemfile(path; kwargs...)\n\nParse a file given in any recognised chemical format and extract the topological information. Such format can be .cif or any file format recognised by Chemfiles.jl that contains all the necessary topological information.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.topological_genome","page":"Public","title":"CrystalNets.topological_genome","text":"topological_genome(net::CrystalNet{D,T})::String where {D,T}\n\nCompute the topological genome of a net. The topological genome is an invariant if the net, meaning that it does not depend on its representation. It is also the string representation of a D-periodic graph such that PeriodicGraph{D}(topological_genome(net)) is isomorphic to net.pge.g (except possibly if the ignore_types option is unset).\n\nReturn a TopologicalGenome.\n\ninfo: Info\nOptions must be passed directly within net.\n\n\n\n\n\ntopological_genome(g::Union{String,PeriodicGraph}, options::Options=Options())\ntopological_genome(g::Union{String,PeriodicGraph}; kwargs...)\n\nCompute the topological genome of a periodic graph. If given a topological key (as a string), it is converted to a PeriodicGraph first.\n\nReturn a TopologicalGenome.\n\n\n\n\n\ntopological_genome(group::UnderlyingNets)\n\nCompute the topological genome of each subnet stored in group.\n\nReturn a InterpenetratedTopologyResult\n\ninfo: Info\nOptions must be passed directly within the subnets.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Options","page":"Public","title":"Options","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"CrystalNets.Options\nStructureType\nBonding\nClustering\nCrystalNets.ClusterKinds","category":"page"},{"location":"lib/public/#CrystalNets.Options","page":"Public","title":"CrystalNets.Options","text":"Options\n\nDifferent options, passed as keyword arguments.\n\nBasic options\n\nname: a name for the structure.\nbonding: one of the Bonding options. Default is Bonding.Auto.\nstructure: one of the StructureType options. Default is StructureType.Auto.\nclusterings: a list of Clustering options. Default is [Clustering.Auto].\n\nExports\n\nFor each export option, the accepted values are either a string, indicating the path to the directory in which to store the export, or a boolean, specifying whether or not to do the export. If the value is true, a path will be automatically determined. An empty string is equivalent to false.\n\nexport_input: the parsed structure, as a .vtf\nexport_trimmed: the parsed structure after iteratively removing all atoms having only one neighbour, as a .vtf\nexport_attributions: the attribution of vertices into SBUs, as a .pdb. Only relevant for the MOF StructureType.\nexport_clusters: the clustering of vertices, as a .vtf\nexport_net: the overall extracted net on which the topology is computed, as a .vtf.\nexport_subnets: each connected component of the overall net as a separate .vtf file. These subnets are defined after grouping vertices according to their Clustering.\n\nOther options\n\nignore_atoms: set of atom symbols to ignore (for instance [:C,:H] will remove carbohydrate solvent residues).\nignore_types: disregard atom types to compute the topology, making pcu and pcu-b identical for example (default is true)\ncutoff_coeff: coefficient used to detect bonds. Default is 0.75, higher values will include bonds that were considered too long before.\nskip_minimize: assume that the cell is already the unit cell (default is false).\ndimensions: the set of crystal net dimensions to consider. For instance, putting Set(3) will ensure that only 3-dimensional nets are considered. Default is Set([1,2,3]).\ncluster_kinds: a ClusterKinds. Default separates organic and inorganic SBUs.\nignore_homoatomic_bonds: a Set{Symbol} such that all X-X bonds of the net are removed if X is an atom whose type is in ignore_homoatomic_bonds.\nmax_polyhedron_radius: an integer specifying the maximum number of bonds between two corners of the coordination polyhedron built for the Clustering.PE option. Default is 4.\nHbonds: set to true to include hydrogen bonds. Default is false.\nHbonds_dmax: the maximum length of a hydrogen bond. Only used if Hbonds is set. Default is 2.5 Å.\nHbonds_θmax: the maximum angle of a hydrogen bond. Only used if Hbonds is set. Default is 30°.\nHbonds_nmax: the maximum number of hydrogen bond per hydrogen. Only used if Hbonds is set. Default is 1.\n\nMiscellaneous options\n\nThese boolean options have a default value that may be determined by Bonding, StructureType and Clustering. They can be directly overriden here.\n\nbond_adjacent_sbus: bond together SBUs which are only separated by a single C atom.\nauthorize_pruning: remove colliding atoms in the input. Default is true.\nwider_metallic_bonds: for bond detections, metals have a radius equal to 1.5× their Van der Waals radius. Default is false, unless StructureType is MOF or Zeolite.\nignore_homometallic_bonds: remove all bonds between two metal atoms of the same kind.\nreduce_homometallic_bonds: when guessing bonds, do not bond two metallic atoms of the same type if they are up to third neighbours anyway. Default is false, unless StructureType is MOF.\nignore_metal_cluster_bonds: do not bond two metallic clusters together if they share at least one non-metallic neighbour. Default is false.\nignore_low_occupancy: atoms with occupancy lower than 0.5 are ignored. Default is false.\ndetect_paddlewheels: detect paddle-wheel pattern and group them into an inorganic vertex. Default is true.\ndetect_organiccycles: detect organic cycles and collapse all belonging C atoms into a new vertex. Default is true.\ndetect_pe: detect organic points-of-extension (organic atoms bonded to another SBU) and transform them into vertices. Default is true.\ncluster_simple_pe: cluster adjacent points-of-extension if they are not part of a cycle. Default is true.\nseparate_metals: separate each metal atom into its own vertex (instead of grouping them to form metallic clusters if they are adjacent or bonded by an oxygen). Default is false, unless Clustering is Standard or PEM.\npremerge_metalbonds: when a periodic metallic SBU is detected, cluster together bonded metal atoms of the same kind before splitting the SBU.\nsplit_O_vertex: if a vertex is composed of a single O, remove it and bond together all of its neighbors, unless removing its hydrogen bonds would make it bivalent. Default is false, unless StructureType is MOF or Zeolite.\nunify_sbu_decomposition: apply the same rule to decompose both periodic and finite SBUs. Default is false.\nforce_warn: force printing warning and information even during ..._dataset function calls. Default is false.\nlabel_for_type: use the atom label instead of its type. Default is false. Note that setting this to true will result in an error when detecting bonds if any atom has a label which is not an element of the periodic table.\ntrack_mapping: track the mapping of vertices from the input to the final genome. To use it, set true: at the end of the topology computation, the track_mapping field will hold a list l such that l[i] is the number of vertex in the result topology that corresponds to atom i in the initial structure. In the case of determine_topology... calls, this initial structure is the file exported through the export_input option. Default is nothing, which does no tracking. track_mapping also accepts being set to Int[] instead of true: the list will then be modified in-place.\nkeep_single_track: set to false to modify the behaviour of the track_mapping option. By default (true), track_mapping is only allowed when the structure corresponds to a single topology: this excludes structures with multiple connected components, as well as multiple values in clusterings. This is necessary since otherwise the list held in track_mapping at the end of the computation could refer to any of multiple topologies. Setting keep_single_track to false lifts this requirement; in this case, the mapping will be printed at the end of the topology computation for each topology, but it will not be held in the track_mapping field (and will not be made computationally accessible).\n\nInternal fields\n\nThese fields are for internal use and should not be modified by the user:\n\ndryrun: store information on possible options to try (for guess_topology).\n_pos: the positions of the centre of the clusters collapsed into vertices.\nerror: store the first error that occured when building the net.\nthrow_error: if set, throw the error instead of storing it in the error field.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystalNets.StructureType","page":"Public","title":"CrystalNets.StructureType","text":"StructureType\n\nSelection mode for the crystal structure. This choice impacts the bond detection algorithm as well as the clustering algorithm used.\n\nThe choices are:\n\nAuto: No specific structure information. Use Van der Waals radii for bond detection and Input as Clustering, or EachVertex if the input does not provide residues.\nMOF: Use Van der Waals radii for non-metallic atoms and larger radii for metals. Detect organic and inorganic clusters and subdivide them according to AllNodes and SingleNodes to identify underlying nets.\nCluster: similar to MOF but metallic atoms are not given a wider radius.\nZeolite: Same as Auto but use larger radii for metals (and metalloids) and attempt to enforce that each O atom has exactly two neighbours and that they are not O atoms.\nGuess: try to identify the clusters as in Cluster. If it fails, fall back to Auto.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CrystalNets.Bonding","page":"Public","title":"CrystalNets.Bonding","text":"Bonding\n\nSelection mode for the detection of bonds. The choices are:\n\nInput: use the input bonds. Fail if those are not specified.\nGuess: guess bonds using a variant of chemfiles / VMD algorithm.\nAuto: if the input specifies bonds, use them unless they look suspicious (too small or or too large according to a heuristic). Otherwise, fall back to Guess.\nNoBond: do not guess or use any bond. This cannot be used to determine topology.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CrystalNets.Clustering","page":"Public","title":"CrystalNets.Clustering","text":"Clustering\n\nThe clustering algorithm used to group atoms into vertices.\n\nThis choice only affects the creation of a UnderlyingNets from a Crystal, not the Crystal itself, and in particular not the bond detection algorithm.\n\nThe basic choices are:\n\nAuto: determined using the StructureType.\nInput: use the input residues as vertices. Fail if some atom does not belong to a residue.\nEachVertex: each atom is its own vertex. Vertices with degree 2 or lower are iteratively collapsed into edges until all vertices have degree 3 or more.\n\nThe next clustering options are designed for MOFs but may target other kinds of frameworks. In all cases, the clusters are refinements on top of already-defined clusters, such as the organic and inorganic SBUs defined by the MOF structure. Except for AllNodes, infinite clusters (such as the inorganic clusters in a rod MOF) are split into new finite clusters using heuristics.\n\nSingleNodes: each already-defined cluster is mapped to a vertex.\nAllNodes: keep points of extension for organic clusters.\nStandard: make each metallic atom its own vertex and do not bond those together if they share a common non-metallic neighbour.\nPE: stands for Points of Extension. Keep points of extension for organic clusters, remove metallic centres and bond their surrounding points of extension.\nPEM: stands for Points of Extension and Metals. Keep points of extension for organic clusters and each metal centre as a separate vertex.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CrystalNets.ClusterKinds","page":"Public","title":"CrystalNets.ClusterKinds","text":"ClusterKinds(sbus, toclassify=Int[])\n\nDescription of the different kinds of SBUs there should be when making clusters.\n\nsbus should be a list of set of symbols, each set containing the different elements acceptable in this SBU (an empty set designates all remaining elements). All elements of the same category of the periodic table can be grouped together by putting the name of the category. For example, ClusterKinds([[:Au, :halogen, :nonmetal], [:metal, :metalloid], []]) means that there are three kinds of SBUs:\n\nthe first kind can only hold halogens, non-metals and Au atoms\nthe second kind can only hold metalloids and metals (except Au)\nthe third kind can hold all the other elements.\n\nThe list of possible categories is: :actinide, :noble (for noble gas), :halogen, :lanthanide, :metal, :metalloid and :nonmetal.\n\ntoclassify contains the list of SBUs which are not actual SBUs but only groups of atoms waiting to be merged to a neighboring SBU. The neighboring SBU is chosen by order in the sbus list.\n\nThe cluster kinds used by default are CrystalNets.ClusterKinds([[:metal, :actinide, :lanthanide], [:C,], [:P, :S],                            [:nonmetal, :metalloid, :halogen], [:noble]], [3, 4]). This means that all atoms that are either metals, actinides or lanthanides are assigned to class 1 and all C atoms in SBUs of class 2. Afterwards, each group of adjacent P or S atoms is assigned either class 1 if any of its neighbor is of class 1, or class 2 otherwise if any of its neighbor is of class 2. If no such neighbor exist, it is assigned to class 1. Finally, each group of adjacent nonmetals, metalloids and halogens is assigned class 1 or 2 following the same rule as for P and S atoms.\n\nAt the end of the procedure, all atoms are thus given a class between 1 and length(sbus) which is not in toclassify. See also find_sbus! for the implementation of this procedure.\n\nTo determine which SBU kind corresponds to a given atom, use getindex:\n\njulia> sbu_kinds = CrystalNets.ClusterKinds([[:nonmetal, :halogen], [:metal, :F]]);\n\njulia> sbu_kinds[:O] # nonmetal\n1\n\njulia> sbu_kinds[:Au] # metal\n2\n\njulia> sbu_kinds[:F] # specifically F\n2\n\njulia> sbu_kinds[:Ne] # no given SBU kind\n0\n\nIf no empty set has been explicitly added to sbus and an element falls outside of the included categories, the returned SBU kind is 0.\n\nAn exception is made for nonmetals which are part of an aromatic heterocycle: those will be treated separately and put in the SBU of the corresponding carbons.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Other-utilities","page":"Public","title":"Other utilities","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"CrystalNets.toggle_error\nCrystalNets.toggle_warning\nCrystalNets.toggle_export\nCrystalNets.export_default\none_topology","category":"page"},{"location":"lib/public/#CrystalNets.toggle_error","page":"Public","title":"CrystalNets.toggle_error","text":"toggle_error(to=nothing)\n\nToggle @error visibility on (if to == true) or off (if to == false). Without an argument, toggle on and off repeatedly at each call.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.toggle_warning","page":"Public","title":"CrystalNets.toggle_warning","text":"toggle_warning(to=nothing)\n\nToggle warnings on (if to == true) or off (if to == false). Without an argument, toggle on and off repeatedly at each call.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.toggle_export","page":"Public","title":"CrystalNets.toggle_export","text":"toggle_export(to=nothing)\n\nToggle default exports on (if to == true) or off (if to == false). Without an argument, toggle on and off repeatedly at each call.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.export_default","page":"Public","title":"CrystalNets.export_default","text":"export_default(c::Union{PeriodicGraph,CrystalNet,Crystal}, obj=nothing, name=nothing, path=tempdir(); repeats=nothing)\n\nExport a VTF representation of an object at the given path.\n\nobj is a String describing the nature of the object, such as \"net\", \"clusters\" or \"subnet\" for example. Default is string(typeof(c)).\n\nname is a String inserted in the exported file name. Default is a tempname.\n\nrepeats is the maximum distance between a represented atom out of the unit cell and one inside. Default is between 2 and 6, depending on obj and the size of the graph.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.one_topology","page":"Public","title":"CrystalNets.one_topology","text":"one_topology(itr::InterpenetratedTopologyResult, clustering::Union{Nothing,_Clustering}=nothing)\n\nReturn the only topology corresponding to the given clustering. If no clustering is given, return the only topology of the result.\n\nIf several topologies are found, return nothing.\n\nIf the clustering is not found in one of the interpenetrated topologies, return missing.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Archive","page":"Public","title":"Archive","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"REVERSE_CRYSTALNETS_ARCHIVE\nCrystalNets.parse_arc\nCrystalNets.parse_arcs\nclean_default_archive!\nset_default_archive!\nempty_default_archive!\nchange_current_archive!\nrefresh_current_archive!\nadd_to_current_archive!\nCrystalNets.export_arc","category":"page"},{"location":"lib/public/#CrystalNets.REVERSE_CRYSTALNETS_ARCHIVE","page":"Public","title":"CrystalNets.REVERSE_CRYSTALNETS_ARCHIVE","text":"const REVERSE_CRYSTALNETS_ARCHIVE::Dict{String,String}\n\nReverse of CRYSTALNETS_ARCHIVE.\n\nCan be used to query the topological genome of known nets, as in:\n\njulia> REVERSE_CRYSTALNETS_ARCHIVE[\"dia\"]\n\"3 1 2 0 0 0 1 2 0 0 1 1 2 0 1 0 1 2 1 0 0\"\n\njulia> topological_genome(CrystalNet(PeriodicGraph(ans)))\ndia\n\nnote: Note\nIt is also possible to directly access the topological genome as a PeriodicGraph by parsing the name as a TopologicalGenome:julia> PeriodicGraph(parse(TopologicalGenome, \"pcu\"))\nPeriodicGraph3D(1, PeriodicEdge3D[(1, 1, (0,0,1)), (1, 1, (0,1,0)), (1, 1, (1,0,0))])\n\njulia> string(PeriodicGraph(parse(TopologicalGenome, \"nbo\"))) == REVERSE_CRYSTALNETS_ARCHIVE[\"nbo\"]\ntrue\n\n\n\n\n\n","category":"constant"},{"location":"lib/public/#CrystalNets.parse_arc","page":"Public","title":"CrystalNets.parse_arc","text":"parse_arc(file)\n\nParse a .arc Systre archive such as the one used by the RCSR. Return a pair (flag, pairs).\n\nflag is set if the archive corresponds to one generated by a compatible release of CrystalNets. If unset, the genomes of the archive may not be the same as those computed by CrystalNets for the same nets. pairs is a Dict{String,String} whose entries have the form genome => id where id is the name of the net and genome is the topological genome corresponding to this net (given as a string of whitespace-separated values parseable by PeriodicGraph).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.parse_arcs","page":"Public","title":"CrystalNets.parse_arcs","text":"parse_arcs(file)\n\nParse a folder containing .arc Systre archives such as the one used by the RCSR. Return a pair (flag, pairs) with the same convention than parse_arc.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.clean_default_archive!","page":"Public","title":"CrystalNets.clean_default_archive!","text":"clean_default_archive!(custom_arc; validate=true, refresh=true)\n\nErase the default archive used by CrystalNets.jl to recognize known topologies and replace it with a new one from the file located at custom_arc.\n\nThe validate parameter controls whether the new file is checked and converted to a format usable by CrystalNets.jl. If unsure, leave it set.\n\nThe refresh optional parameter controls whether the current archive should be replaced by the new default one.\n\nwarning: Warning\nThis archive will be kept and used for subsequent runs of CrystalNets.jl, even if you restart your Julia session.To only change the archive for the current session, use change_current_archive!(custom_arc).See also refresh_current_archive! for similar uses.\n\nwarning: Warning\nThe previous default archive cannot be recovered afterwards, so make sure to keep a copy if necessary. The default archive is the set of \".arc\" files located at joinpath(dirname(dirname(pathof(CrystalNets))), \"archives\").\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.set_default_archive!","page":"Public","title":"CrystalNets.set_default_archive!","text":"set_default_archive!()\n\nSet the current archive as the new default archive.\n\nwarning: Warning\nThis archive will be kept and used for subsequent runs of CrystalNets.jl, even if you restart your Julia session.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.empty_default_archive!","page":"Public","title":"CrystalNets.empty_default_archive!","text":"empty_default_archive!(; refresh=true)\n\nEmpty the default archive. This will prevent CrystalNets from recognizing any topology before they are explicitly added.\n\nThe refresh optional parameter controls whether the current archive should also be emptied.\n\nwarning: Warning\nThis empty archive will be kept and used for subsequent runs of CrystalNets.jl, even if you restart your Julia session. If you only want to empty the current archive, do empty!(CrystalNets.CRYSTALNETS_ARCHIVE).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.change_current_archive!","page":"Public","title":"CrystalNets.change_current_archive!","text":"change_current_archive!(custom_arc; validate=true)\n\nErase the current archive used by CrystalNets.jl to recognize known topologies and replace it with the archive stored in the file located at custom_arc.\n\nThe validate optional parameter controls whether the new file is checked and converted to a format usable by CrystalNets.jl. If unsure, leave it set.\n\nnote: Note\nThis modification will only last for the duration of this Julia session.If you wish to change the default archive and use it for subsequent runs, use clean_default_archive!.\n\nwarning: Warning\nUsing an invalid archive will make CrystalNets.jl unusable. If this happens, simply run refresh_current_archive!() to revert to the default archive.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.refresh_current_archive!","page":"Public","title":"CrystalNets.refresh_current_archive!","text":"refresh_current_archive!()\n\nRevert the current topological archive to the default one.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.add_to_current_archive!","page":"Public","title":"CrystalNets.add_to_current_archive!","text":"add_to_current_archive!(id, genome)\n\nMark genome as the topological genome associated with the name id in the current archive.\n\nThe input id and genome are not modified by this operation.\n\nnote: Note\nThis modification will only last for the duration of this Julia session.If you wish to save the archive and use it for subsequent runs, use set_default_archive! after calling this function.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystalNets.export_arc","page":"Public","title":"CrystalNets.export_arc","text":"export_arc(path, arc=CRYSTALNETS_ARCHIVE)\n\nExport archive arc to the specified path. If unspecified, the exported archive is the current one.\n\n\n\n\n\n","category":"function"}]
}
