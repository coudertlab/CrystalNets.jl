<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · CrystalNets.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CrystalNets.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../man/visualization/">Visualization</a></li><li><a class="tocitem" href="../../faq/">FAQ</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../public/">Public</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Core-topology-functions"><span>Core topology functions</span></a></li><li><a class="tocitem" href="#Input"><span>Input</span></a></li><li><a class="tocitem" href="#Crystal-and-CIF-handling"><span>Crystal and CIF handling</span></a></li><li><a class="tocitem" href="#Bond-guessing"><span>Bond guessing</span></a></li><li><a class="tocitem" href="#Clustering-algorithm"><span>Clustering algorithm</span></a></li><li><a class="tocitem" href="#Unstable-nets"><span>Unstable nets</span></a></li><li><a class="tocitem" href="#Utils"><span>Utils</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/coudertlab/CrystalNets.jl/blob/master/docs/src/lib/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-types-and-functions"><a class="docs-heading-anchor" href="#Internal-types-and-functions">Internal types and functions</a><a id="Internal-types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-types-and-functions" title="Permalink"></a></h1><p>See also the documentations of <a href="https://liozou.github.io/PeriodicGraphs.jl/"><code>PeriodicGraphs.jl</code></a> and of <a href="https://liozou.github.io/PeriodicGraphEmbeddings.jl"><code>PeriodicGraphEmbeddings.jl</code></a></p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.Crystal" href="#CrystalNets.Crystal"><code>CrystalNets.Crystal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Crystal</code></pre><p>Intermediate representation of a crystal, retaining information on the cell, and the fractional placement of the atoms and their type, as well as the residues which will be used as vertices for the computation of the underlying topology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/types.jl#L435-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.Clusters" href="#CrystalNets.Clusters"><code>CrystalNets.Clusters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Clusters</code></pre><p>Classification of the atoms of a crystalline framework in different clusters. For simple crystals, every atom is its own cluster. For a MOF, a cluster is a SBU, which can be either organic or inorganic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/types.jl#L380-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.CollisionNode" href="#CrystalNets.CollisionNode"><code>CrystalNets.CollisionNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CollisionNode</code></pre><p>Store the structure of a collision node through the subgraph <code>g</code> extracted with only the edges bond to the vertices in the node.</p><p>The <code>num</code> field corresponds to the number of vertices in <code>g</code> that collide in the initial graph, while the <code>neighs</code> field stores the indices of their neighbors out of the collision site.</p><p>The colliding vertices are the <code>num</code> first vertices of <code>g</code>, the others are the neighbors. In particular, <code>nv(g) == num + length(neighs)</code> and <code>g[(num+1):(nv(g))]</code> has no edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/stability.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.CIF" href="#CrystalNets.CIF"><code>CrystalNets.CIF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CIF</code></pre><p>Representation of a .cif file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/types.jl#L14-L18">source</a></section></article><h2 id="Core-topology-functions"><a class="docs-heading-anchor" href="#Core-topology-functions">Core topology functions</a><a id="Core-topology-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-topology-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.topological_key" href="#CrystalNets.topological_key"><code>CrystalNets.topological_key</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">topological_key(net::CrystalNet)</code></pre><p>Return a unique topological key for the net, which is a topological invariant of the net (i.e. it does not depend on its initial representation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L955-L960">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.CRYSTALNETS_ARCHIVE" href="#CrystalNets.CRYSTALNETS_ARCHIVE"><code>CrystalNets.CRYSTALNETS_ARCHIVE</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const CRYSTALNETS_ARCHIVE::Dict{String,String}</code></pre><p>The archive used to recognize known topologies.</p><p>You probably don&#39;t need to access it directly: rely on <a href="../public/#CrystalNets.recognize_topology"><code>recognize_topology</code></a> to read and the various archive functions like <a href="../public/#CrystalNets.add_to_current_archive!"><code>add_to_current_archive!</code></a> to write.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/archive.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.minimize" href="#CrystalNets.minimize"><code>CrystalNets.minimize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minimize(net::CrystalNet, [collisions::Vector{CollisionNode}])</code></pre><p>Return a CrystalNet representing the same net as the input, but in a unit cell. If <code>collisions</code> is given, also return the corresponding collisions after minimization.</p><p>The computed unit cell may depend on the representation of the input, i.e. it is not topologicallly invariant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L322-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.candidate_key" href="#CrystalNets.candidate_key"><code>CrystalNets.candidate_key</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">candidate_key(net::CrystalNet, u, basis, minimal_edgs)</code></pre><p>Given the net, a candidate <code>u =&gt; basis</code> where <code>u</code> is the origin and <code>basis</code> the triplet of axes, and <code>minimal_edgs</code> the last minimal key (for the pseudo-lexicographical order used), extract the key corresponding to the current candidate.</p><p>The key is the lexicographically ordered list of edges of the graph when its vertices are numbered according to the candidate. The ordering of keys first compares the list of edges disregarding the offsets, and then only compares the offsets if the rest is identical.</p><p>If the key is larger or equal to <code>minimal_edgs</code>, early stop and return two empty lists. Otherwise, the extracted key is the current best: return the vmap between the initial vertices and their ordered image in the candidate, as well as the key.</p><p>See also: <a href="#CrystalNets.find_candidates"><code>find_candidates</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L407-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.possible_translations" href="#CrystalNets.possible_translations"><code>CrystalNets.possible_translations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">possible_translations(c::CrystalNet)</code></pre><p>Return a list of tuples <code>(nz, i_max_den, max_den, t)</code> where</p><ul><li><code>t</code> is a translation mapping at the origin vertex to another one in the unit cell.</li><li><code>max_den</code> is the maximum denominator in the <code>D</code> coefficients of <code>t</code>.</li><li><code>i_max_den</code> is the index.</li><li><code>nz</code> is the number of zeros in <code>t</code>.</li></ul><p>The list is guaranteed to contain all the possible valid translations but may contain some invalid translations.</p><p>See also: <a href="#CrystalNets.find_all_valid_translations"><code>find_all_valid_translations</code></a>, <code>PeriodicGraphEmbeddings.check_valid_symmetry</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L28-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.find_all_valid_translations" href="#CrystalNets.find_all_valid_translations"><code>CrystalNets.find_all_valid_translations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_all_valid_translations(c::CrystalNet{D}, collisions) where D</code></pre><p>Return a <code>D</code>-tuple of list of tuples <code>(i_max_den, max_den, t)</code> (see <a href="#CrystalNets.possible_translations"><code>possible_translations</code></a> for interpretation) where the <code>n</code>-th list contains all valid translations of the net having exactly <code>n-1</code> zeros.</p><p>A translation is valid if it maps exactly each vertex to a vertex and each edge to an edge.</p><p>See also: <a href="#CrystalNets.possible_translations"><code>possible_translations</code></a>, <code>PeriodicGraphEmbeddings.check_valid_symmetry</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L58-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.minimal_volume_matrix" href="#CrystalNets.minimal_volume_matrix"><code>CrystalNets.minimal_volume_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minimal_volume_matrix(translations::NTuple{D}) where {D}</code></pre><p>Given the output of <a href="#CrystalNets.find_all_valid_translations"><code>find_all_valid_translations</code></a>, compute the transformation that allows reducing the net to its minimal cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.reduce_with_matrix" href="#CrystalNets.reduce_with_matrix"><code>CrystalNets.reduce_with_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reduce_with_matrix(c::CrystalNet, mat, shrunk_net, collisions)</code></pre><p>Given the net and the output of <code>minimal_volume_matrix</code> computed on the valid translations of the net, return the new net representing the initial net in the computed unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.partition_by_coordination_sequence" href="#CrystalNets.partition_by_coordination_sequence"><code>CrystalNets.partition_by_coordination_sequence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partition_by_coordination_sequence(graph, symmetries::AbstractSymmetryGroup=NoSymmetryGroup(graph))</code></pre><p>Partition the vertices of the graph into disjoint categories, one for each coordination sequence. The partition is then sorted by order of coordination sequence. This partition does not depend on the representation of the graph. The optional argument <code>vmaps</code> is a set of permutations of the vertices that leave the graph unchanged. In other words, <code>vmaps</code> is a set of symmetry operations of the graph.</p><p>Return the categories and a list of unique representative for each symmetry class.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L490-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.find_candidates" href="#CrystalNets.find_candidates"><code>CrystalNets.find_candidates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_candidates(net::CrystalNet{D}, collisions::Vector{CollisionNode}) where D</code></pre><p>Return a non-empty set of candidates <code>u =&gt; basis</code> where <code>u</code> is a vertex and <code>basis</code> is matrix whose columns are <code>D</code> linearly independent euclidean embeddings of edges. The returned set is independent of the representation of the graph used in <code>net</code>.</p><p>Also return a <code>category_map</code> linking each vertex to its category number, as defined by <a href="#CrystalNets.partition_by_coordination_sequence"><code>partition_by_coordination_sequence</code></a></p><p>See also: <a href="#CrystalNets.candidate_key"><code>candidate_key</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L577-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.extract_through_symmetry" href="#CrystalNets.extract_through_symmetry"><code>CrystalNets.extract_through_symmetry</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_through_symmetry(candidates::Dict{Int,Vector{SMatrix{3,3,T,9}}}, symmetries::AbstractSymmetryGroup) where T</code></pre><p>Given the candidates and the list of symmetries of the net, return the flattened list of candidates after removing candidates that are symmetric images of the kept ones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L644-L649">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.find_initial_candidates" href="#CrystalNets.find_initial_candidates"><code>CrystalNets.find_initial_candidates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_initial_candidates(net::CrystalNet{D}, candidates_v, category_map) where D</code></pre><p>Given the net, a list of vertices in a given category and the <code>category_map</code>, return a list of pairs <code>u =&gt; (basis, cats)</code> where <code>u ∈ candidates_v</code>, <code>basis</code> is a <code>D</code>-rank matrix made by juxtaposing the euclidean embeddings of outgoing edges from <code>u</code>, and <code>cats</code> are the categories of the respective neighbors of <code>u</code>.</p><p>If the <code>basis</code> corresponding to vertex <code>u</code> is not of rank <code>D</code>, it is not included in the returned list (for instance, if all outgoing edges of a vertex are coplanar with <code>D == 3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L679-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.find_candidates_onlyneighbors" href="#CrystalNets.find_candidates_onlyneighbors"><code>CrystalNets.find_candidates_onlyneighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_candidates_onlyneighbors(net::CrystalNet{D}, candidates_v, category_map) where D</code></pre><p>Given the net, a list of vertices in a given category and the <code>category_map</code>, return a Dict whose pairs <code>u =&gt; matv</code> are such that <code>u ∈ candidates_v</code> and <code>matv</code> is a list of unique invertible matrices of size <code>D</code> whose columns are euclidean embeddings of outgoing edges from <code>u</code>. Each such matrix has a category, defined by the <code>D</code>-uplet of categories of each corresponding outneighbor of <code>u</code>: the returned Dict is such that all the matrices belonging to all <code>matv</code> share the same category.</p><p>The returned Dict is empty iff <code>find_initial_candidates(net, candidates_v, category_map)</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L715-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.find_candidates_fallback" href="#CrystalNets.find_candidates_fallback"><code>CrystalNets.find_candidates_fallback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_candidates_fallback(net::CrystalNet3D, reprs, othercats, category_map)</code></pre><p>Return candidates in the same form as <a href="#CrystalNets.find_candidates_onlyneighbors"><code>find_candidates_onlyneighbors</code></a> except that only two edges start from <code>u</code> and one does not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L878-L883">source</a></section></article><h2 id="Input"><a class="docs-heading-anchor" href="#Input">Input</a><a id="Input-1"></a><a class="docs-heading-anchor-permalink" href="#Input" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.parse_cif" href="#CrystalNets.parse_cif"><code>CrystalNets.parse_cif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse_cif(file_path)</code></pre><p>Parse a CIF file and return a dictionary where each identifier (without the starting &#39;_&#39; character) is linked to its value. Values are either a string or a vector of string (if defined in a loop).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/input.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.CIF-Tuple{AbstractString}" href="#CrystalNets.CIF-Tuple{AbstractString}"><code>CrystalNets.CIF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CIF(file_path::AbstractString)</code></pre><p>Make a CIF object out of the parsed file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/input.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.check_collision" href="#CrystalNets.check_collision"><code>CrystalNets.check_collision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_collision(pos, mat)</code></pre><p>Given a list of fractional coordinates <code>pos</code> and the matrix of the unit cell <code>mat</code>, return a list of atoms that are suspiciously close to another atom of the list. For each collision site, only one atom is not present in the returned list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/input.jl#L486-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.fix_atom_on_a_bond!" href="#CrystalNets.fix_atom_on_a_bond!"><code>CrystalNets.fix_atom_on_a_bond!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fix_atom_on_a_bond!(graph, pos, mat)</code></pre><p>Remove bonds that are intercepted by an atom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/input.jl#L517-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.least_plausible_neighbours" href="#CrystalNets.least_plausible_neighbours"><code>CrystalNets.least_plausible_neighbours</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">least_plausible_neighbours(Δs, n)</code></pre><p>Find the positions of the n least probable neighbours of an atom, given the list Δs of the distance between their position and that of the atom.</p><p>This function is highly empirical and should not be considered utterly reliable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/input.jl#L548-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.fix_valence!" href="#CrystalNets.fix_valence!"><code>CrystalNets.fix_valence!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fix_valence!(graph::PeriodicGraph3D, pos, types, passH, passO, passCN, mat, ::Val{dofix}, options) where {dofix}</code></pre><p>Attempt to ensure that the coordinence of certain atoms are at least plausible by removing some edges from the graph. These atoms are H, halogens, O, N and C. if <code>dofix</code> is set, actually modify the graph; otherwise, only emit a warning. In both cases, return a list of atoms with invalid coordinence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/input.jl#L600-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.sanitize_removeatoms!" href="#CrystalNets.sanitize_removeatoms!"><code>CrystalNets.sanitize_removeatoms!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sanitize_removeatoms!(graph::PeriodicGraph3D, pos, types, mat, options)</code></pre><p>Special heuristics to remove atoms that seem to arise from an improper cleaning of the file. Currently implemented:</p><ul><li>C atoms suspiciously close to metallic atoms.</li><li>One of two identical metallic atoms suspiciously close to one another</li></ul><p>TODO:</p><ul><li>O atoms with 4 coplanar bonds (warning only).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/input.jl#L644-L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.remove_triangles!" href="#CrystalNets.remove_triangles!"><code>CrystalNets.remove_triangles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_triangles!(graph::PeriodicGraph3D, pos, types, mat, toinvestigate=collect(edges(graph)))</code></pre><p>In a configuration where atoms A, B and C are pairwise bonded, remove the longest of the three bonds if it is suspicious (too large and too close to the third atom).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/input.jl#L706-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.remove_homoatomic_bonds!" href="#CrystalNets.remove_homoatomic_bonds!"><code>CrystalNets.remove_homoatomic_bonds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_homoatomic_bonds!(graph::PeriodicGraph, types, targets, ignore_homometallic)</code></pre><p>Remove from the graph all bonds of the form X-X where X is an atom in <code>targets</code>. Also remove all such bonds where X is a metal if the two bonded atoms up to third neighbours otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/input.jl#L978-L984">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.sanity_checks!" href="#CrystalNets.sanity_checks!"><code>CrystalNets.sanity_checks!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sanity_checks!(graph, pos, types, mat, options)</code></pre><p>Perform some sanity checks to ensure that the detected bonds are not obviously wrong because they are either too short or too long.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/input.jl#L850-L855">source</a></section></article><h2 id="Crystal-and-CIF-handling"><a class="docs-heading-anchor" href="#Crystal-and-CIF-handling">Crystal and CIF handling</a><a id="Crystal-and-CIF-handling-1"></a><a class="docs-heading-anchor-permalink" href="#Crystal-and-CIF-handling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.remove_partial_occupancy" href="#CrystalNets.remove_partial_occupancy"><code>CrystalNets.remove_partial_occupancy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_partial_occupancy(::CIF)</code></pre><p>Only keep one atom per atom site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/types.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.prune_collisions" href="#CrystalNets.prune_collisions"><code>CrystalNets.prune_collisions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prune_collisions(::CIF)</code></pre><p>For each site where there are atoms suspiciously close to one another, remove all but one of them. This arises for example when all the possible positions of at atom are superposed in the CIF file, typically for a solvent which should be disregarded anyway.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/types.jl#L175-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.expand_symmetry" href="#CrystalNets.expand_symmetry"><code>CrystalNets.expand_symmetry</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand_symmetry(::CIF)</code></pre><p>Applies all the symmetry operations listed in the CIF file to the atoms and the bonds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/types.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.trim_monovalent" href="#CrystalNets.trim_monovalent"><code>CrystalNets.trim_monovalent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trim_monovalent(crystal)</code></pre><p>Repeatedly remove monovalent atoms from the crystal until none is left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/clustering.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.trimmed_crystal" href="#CrystalNets.trimmed_crystal"><code>CrystalNets.trimmed_crystal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trimmed_crystal(c::Crystal{Nothing})</code></pre><p>Rebuild the crystal after trimming its graph according to <a href="#CrystalNets.trim_topology"><code>trim_topology</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/types.jl#L500-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.trim_topology" href="#CrystalNets.trim_topology"><code>CrystalNets.trim_topology</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trim_topology(graph::PeriodicGraph)</code></pre><p>Return a pair <code>(vmap, newgraph)</code> extracted from the input by removing vertices of valence lower or equal to 1, and by replacing vertices of valence 2 by edges, until convergence. The only exceptions are vertices only bonded to their representatives of another cell: those will not be replaced by edges even if their valence is 2, since this latter case indicates an irreducible trivial 1-dimensional topology.</p><p><code>vmap</code> maps the vertices of <code>newgraph</code> to their counterpart in <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/types.jl#L536-L547">source</a></section></article><h2 id="Bond-guessing"><a class="docs-heading-anchor" href="#Bond-guessing">Bond guessing</a><a id="Bond-guessing-1"></a><a class="docs-heading-anchor-permalink" href="#Bond-guessing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.guess_bonds" href="#CrystalNets.guess_bonds"><code>CrystalNets.guess_bonds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">guess_bonds(pos, types, mat, options)</code></pre><p>Return the bonds guessed from the positions, types and cell matrix, given as a <code>Vector{Vector{Tuple{Int,Float32}}}</code>.</p><p>The <code>i</code>-th entry of the list is a list, whose entries are of the form <code>(j, dist)</code> which indicates that the representatives of vertices <code>i</code> and <code>j</code> distant of at most <code>dist</code> are bonded together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/guessbonds.jl#L34-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.edges_from_bonds" href="#CrystalNets.edges_from_bonds"><code>CrystalNets.edges_from_bonds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edges_from_bonds(bonds::Vector{Vector{Tuple{Int,Float32}}}, mat, pos)</code></pre><p>Given a bond list <code>bonds</code> containing triplets <code>(a, b, dist)</code> where atoms <code>a</code> and <code>b</code> are bonded if their distance is lower than <code>dist</code>, the 3×3 matrix of the cell <code>mat</code> and the Vector{SVector{3,Float64}} <code>pos</code> whose elements are the fractional positions of the atoms, extract the list of PeriodicEdge3D corresponding to the bonds. Since the adjacency matrix wraps bonds across the boundaries of the cell, the edges are extracted so that the closest representatives are chosen to form bonds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/types.jl#L335-L344">source</a></section></article><h2 id="Clustering-algorithm"><a class="docs-heading-anchor" href="#Clustering-algorithm">Clustering algorithm</a><a id="Clustering-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering-algorithm" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.find_sbus" href="#CrystalNets.find_sbus"><code>CrystalNets.find_sbus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_sbus(crystal, kinds=default_sbus)</code></pre><p>Recognize SBUs using heuristics based on the atom types corresponding to the <code>AllNodes</code> clustering algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/clustering.jl#L879-L884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.regroup_sbus" href="#CrystalNets.regroup_sbus"><code>CrystalNets.regroup_sbus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regroup_sbus(graph::PeriodicGraph3D, classes::AbstractVector{&lt;:Integer},
             isolate=Int[])</code></pre><p>Given a classification of vertices into classes, separate the vertices into clusters of contiguous vertices belonging to the same class.</p><p><code>isolate</code> is a list where each atom is separated from the rest of its class. Once all such atoms of its class are isolated, we look for the connected components of non-isolated atoms in that class. If such a component has only one neighbours which is an isolated atom, it is added to the vertex of the isolated atom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/clustering.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.regroup_paddlewheel!" href="#CrystalNets.regroup_paddlewheel!"><code>CrystalNets.regroup_paddlewheel!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regroup_paddlewheel!(graph, clusters::Clusters, types, periodicsbus)</code></pre><p>Identify paddle-wheel patterns made of two opposite SBUs and regroup them into one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/clustering.jl#L237-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.split_sbu!" href="#CrystalNets.split_sbu!"><code>CrystalNets.split_sbu!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">split_sbu!(sbus, graph, i_sbu, classes)</code></pre><p>Split SBU number <code>i_sbu</code> into new SBUs according to the updated <code>classes</code>. The first argument <code>sbus</code> is modified in-place. Return the list of newly-created periodic SBUs, if any.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/clustering.jl#L390-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.reclassify!" href="#CrystalNets.reclassify!"><code>CrystalNets.reclassify!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reclassify!(sbus, newperiodicsbus, newclass, graph, types, classof, i_sbu)</code></pre><p>Reclassify the atoms of <code>sbus.sbus[i_sbu])</code> according to the following algorithm:</p><ul><li>Let&#39;s call &quot;target atom&quot; any atom of type <code>typ</code> where <code>classof[typ] == deg</code> and either <code>deg == 0</code> or <code>deg &gt; 0</code> and the degree of the atom is <code>deg</code>.</li><li>Assign a new SBU for each target atom (one new per atom).</li><li>Look at the connected components of atoms in the SBU which are not target atoms. For each connected component that is finite (aperiodic) and has only one neighbor which is a target atom, put that component in the same SBU as the neighbor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/clustering.jl#L448-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.add_to_newclass!" href="#CrystalNets.add_to_newclass!"><code>CrystalNets.add_to_newclass!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_to_newclass!(classes, graph, sbus, new_class, v, types, noneighborof)</code></pre><p>Set the class of <code>v</code> to <code>new_class</code>. Then, grow the newly created class by adding connected components of the SBU of <code>v</code> such that the new class does not become periodic and does not contain any vertex that is a neighbor of a vertex whose type is in <code>noneighborof</code>.</p><p>If <code>types === nothing</code>, disregard the condition on <code>noneighborof</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/clustering.jl#L573-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.group_cycle" href="#CrystalNets.group_cycle"><code>CrystalNets.group_cycle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">group_cycle(organiccycle, types, graph)</code></pre><p>Return a list of Vector{PeriodicVertex3D} where each sublist consists in atoms belonging to the same cycle, and which should thus belong to the same vertex eventually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/clustering.jl#L764-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.collapse_clusters" href="#CrystalNets.collapse_clusters"><code>CrystalNets.collapse_clusters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collapse_clusters(crystal::Crystal)</code></pre><p>Return the list of crystals corresponding to the input where each cluster has been transformed into a new vertex, for each targeted clustering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/clustering.jl#L1449-L1454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.pem_to_pe" href="#CrystalNets.pem_to_pe"><code>CrystalNets.pem_to_pe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pem_to_pe(cryst::Crystal{Nothing})</code></pre><p>Convert <code>PEM</code> result to <code>PE</code> by removing all metallic sbus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/clustering.jl#L1757-L1761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.allnodes_to_singlenodes" href="#CrystalNets.allnodes_to_singlenodes"><code>CrystalNets.allnodes_to_singlenodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allnodes_to_singlenodes(cryst::Crystal)</code></pre><p>Convert <code>AllNodes</code> result to <code>SingleNodes</code> by collapsing all points of extension clusters bonded together into a new organic cluster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/clustering.jl#L1963-L1968">source</a></section></article><h2 id="Unstable-nets"><a class="docs-heading-anchor" href="#Unstable-nets">Unstable nets</a><a id="Unstable-nets-1"></a><a class="docs-heading-anchor-permalink" href="#Unstable-nets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.shrink_collisions" href="#CrystalNets.shrink_collisions"><code>CrystalNets.shrink_collisions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shrink_collisions(net::CrystalNet, collisions)</code></pre><p>Remove all colliding vertices and replace them by one new vertex per <code>CollisionNode</code>, whose neighbours are that of the vertices within.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/stability.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.order_collision" href="#CrystalNets.order_collision"><code>CrystalNets.order_collision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">order_collision(graph::PeriodicGraph, colliding)</code></pre><p>Given collision nodes (in the form of the corresponding list of colliding vertices), find an ordering of them which is independent of the current ordering of these vertices and of vertices which are neither in the collision node nor any of its neighbours. Return a this ordering and a priority list for each colliding vertex, or two empty lists if it fails.</p><p>This function assumes that no vertex in the node has a neighbour in another collision node and that there are no two representatives of the same vertex that are neighbour to some vertices in the range.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/stability.jl#L227-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.expand_collisions" href="#CrystalNets.expand_collisions"><code>CrystalNets.expand_collisions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand_collisions(collisions::Vector{CollisionNode}, graph::PeriodicGraph, vmap)</code></pre><p>Expand each collision node into the appropriate number of vertices so that the resulting graph is isomorphic to the initial one, in a manner that only depends on the current graph. Return the resulting graph.</p><p><code>vmap</code> is the map of vertices between <code>initial_graph</code> (with collapsed collision nodes) and <code>graph</code></p><p>Also return the permutations of nodes of <code>graph</code> prior to expansion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/stability.jl#L463-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.collision_nodes" href="#CrystalNets.collision_nodes"><code>CrystalNets.collision_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collision_nodes(c::CrystalNet)</code></pre><p>Check that the net is stable, i.e. that no two vertices have the same equilibrium placement.</p><p>A net is still considered stable if the collisions in equilibrium placement cannot lead to different topological genomes. In practice, this happens when: A) there is no edge between two collision sites and B) there is no edge between a collision site and two representatives of the same vertex and C) for each collision site, the site is made of at most 4 vertices</p><p>In this case, return the <code>CollisionNodeList</code> with the corresponding <code>CollisionNode</code>s, the list being empty if the net is truly stable. Otherwise, return <code>nothing</code>.</p><p>Also return an updated net where the vertices in a <code>CollisionNode</code> are collapsed into a new vertex, appearing after the non-colliding vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/stability.jl#L357-L373">source</a></section></article><h2 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.@toggleassert" href="#CrystalNets.@toggleassert"><code>CrystalNets.@toggleassert</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@toggleassert expression</code></pre><p>Internal macro used to assert and expression conditionally on a build-time constant. To toggle on or off these assertions, the constant has to be modified in the source code and the module rebuilt afterwards.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/utils.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CrystalNets.check_dimensionality" href="#CrystalNets.check_dimensionality"><code>CrystalNets.check_dimensionality</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_dimensionality(c::CrystalNet)</code></pre><p>Check that the dimensionality of the net (i.e. the number of independent axes along which it is periodic) is equal to <code>D</code>, or throw a DimensionMismatch otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/coudertlab/CrystalNets.jl/blob/d7516f00d074203d992744ec27088551816147e4/src/topology.jl#L4-L9">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public/">« Public</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 3 March 2023 18:41">Friday 3 March 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
